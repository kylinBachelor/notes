#+TITLE: Spring学习笔记（上册）
#+AUTHOR: CONGPEITONG
#+EMAIL: congpeitong2022@163.com
#+startup: overview top-level headlines only
* spring概述
** 学习spring原因
1. 最大程度简化了开发
   spring是一个非常优秀的Java框架，其目的是为了简化Java企业级的开发。
2. 大量公司使用
3. 顶级源码设计
   spring框架源码设计非常优秀，在Java开源项目中可以说是顶级的，所以想提升代码能力，强烈建议多看看spring源码，还有jdk源码。
** 什么是spring
spring是一个简化Java企业级开发的一个框架，
*** 内部技术
+ 控制反转
+ 依赖注入
+ 面向切面编程
+ spring事务管理，
*** spring集成其它框架
+ springMVC
+ springboot
+ springcloud
* 控制反转(IOC)与依赖注入(DI)
** spring中三个核心概念
+ 控制反转（IOC）
+ 依赖注入（DI）
+ 面向切面编程（AOP）
** 依赖关系
当A对象需要调用B对象的方法来实现时，说明A依赖于对象B，A和B是依赖关系。
** spring容器
spring容器的概念，容器可以放很多东西，当我们的程序启动的时候会创建spring容器，会给spring容器一个清单，清单中列出了需要创建的对象以及对象依赖关系，
spring容器会创建和组装好清单中的对象，然后将这些对象存放在spring容器中，当程序中需要使用的时候，可以到容器中查找获取，然后直接使用。
** IOC:控制反转
使用者之前需要一个对象（B）的时候都需要自己去创建和组装所依赖的对象，而现在这些创建和组装都会交给spring容器去帮助完成了，使用者只需要去spring容器中查找需要使用的对象就可以了；
这个过程中B对象的的创建和组装过程被反转了，之前是使用者自己主动去控制的，现在交给spring容器去创建和组装了，对象的构建过程被反转了，所以叫做控制反转；
IOC是面向对象编程中的一种设计原则，主要是为了降低系统代码的耦合度，让系统更加有利于去维护和扩展。
** DI:依赖注入
依赖注入是spring容器中创建对象时给其设置依赖对象的方式，比如给spring一个清单，清单中列出了需要创建B对象以及其它的一些对象（可能包含了B类型中需要依赖的对象），
此时spring在创建B对象的时候，会看到B对象需要依赖于哪些对象，然后去查找以下清单中有没有包含这些被依赖的对象，如果有就去将其创建好，然后将其传递给B对象；
可能B需要依赖于很多对象，B创建之前完全不需要知道其他对象是否存在或者其它对象在哪里以及被他们是如何创建的，而spring容器会将b依赖对象主动创建好并将其注入到B中去,
比如spring容器创建B的时候，发现B需要依赖于A，那么spring容器在清单中找到A的定义并将其创建好之后，注入到B对象中。
** 总结
1. IOC控制反转：它是一种设计理念，将对象的创建和组装的主动权交给了spring容器去做，控制的动作被反转了，降低了系统的耦合度，有利于系统维护和扩展，
   主要就是指需要使用的对象的组装的控制权被反转了，之前是自己要做的，现在交给spring容器去做了。
2. DI依赖注入，表示spring容器中创建对象时给其设置依赖对象的方式，通过某些注入的方式可以让系统更加灵活，比如自动注入等可以让系统变得很灵活。
3. spring容器：主要负责容器中对象的创建，组装，对象查找，
* spring容器基本使用及原理
** IOC容器
IOC容器是具有依赖注入功能的容器，负责 *对象的实例化*  *对象的初始化*  *对象和对象之间依赖关系配置*  *对象的销毁*  *对外提供对象的查找* 等操作，对象
的整个生命周期都是由容器来控制的。我们需要使用的对象都要都由IOC容器进行管理，不需要我们再去手动通过new的方式去创建对象，由IOC容器直接帮我们
组装好，当我们需要使用的时候直接从IOC容器中直接获取就可以了。
*** spring IOC 容器是如何知道需要管理哪些对象的
需要我们给IOC提供一个配置清单，这个配置支持 *XML格式* 和 *Java注解* 的方式。在配置文件中列出需要让IOC容器管理的对象，以及可以指定IOC容器如何构建
这些对象的，当spring容器启动的时候，就会去加载这个配置文件，然后将这些对象给组装好以供外部访问者使用。

这里所说的IOC容器也叫做spring容器。

** Bean概念
由spring容器管理的对象统称为Bean对象，Bean就是普通的Java对象，和我们自己new的对象其实是一样的，只是这些对象是由spring去创建和管理的，我们需要在
配置文件中告诉spring容器需要创建哪些bean对象，所以需要先在配置文件中定义好需要创建的bean对象，这些配置统称为bean定义配置元数据信息，spring容器
通过读取这些bean配置元数据信息来构建和组装我们需要的对象。
** spring容器使用步骤
1. 引入spring相关的maven依赖
2. 创建bean配置文件，比如 bean.xml 配置文件
3. 在bean xml文件中定义好需要spring容器管理的bean对象
4. 创建spring容器，并给spring容器指定需要装载的bean配置文件，当spring容器启动之后，会加载这些配置文件，然后创建好配置文件中定义好的bean对象，
   将这些对象放在容器中以供使用
5. 通过容器提供的方法获取容器中的对象，然后使用
** spring容器对象
spring 内部提供了很多spring容器的接口和对象，看几个比较常见的几个容器接口和具体的实现类
*** BeanFactory接口
#+begin_src java
org.springframwork.beans.factory.BeanFactory
#+end_src
spring容器中具有代表性的容器就是BeanFactory接口，这个是spring容器的顶层接口，提供了容器最基本的功能
**** 常用的几个方法
#+begin_src java
  // 按bean的id或者别名查找容器中的bean
  Object getBean(String name) throws BeansException;
  // 这是一个泛型方法，按照bean的id或者别名查找指定类型的bean，返回指定类型的bean对象
  <T> T getBean(String name, Class<T> requiredType) throws BeansException;
  // 返回容器中指定类型的bean对象
  <T> T getBean(Class<T> requiredType) throws BeansException;
  // 获取指定类型bean对象的获取器，这个方法比较特别以后专门来讲
  <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);
#+end_src
*** ApplicationContext接口
#+begin_src java
org.springframwork.context.ApplicationContext
#+end_src
这个接口继承了BeanFactory接口，所以内部包含了BeanFactory所有的功能，并且在其上进行了扩展，增加了很多企业级的功能
+ AOP
+ 国际化
+ 事件支持
+ 。。。。。
*** ClassPathXmlApplicationContext类
#+begin_src java
org.springframwor.context.support.Classpathxmlapplicationcontext
#+end_src
这个类实现了ApplicationContext接口，注意一下这个类名称包含了ClassPath XML,说明了这个容器类可以从ClassPath中加载bean xml配置文件，
然后创建xml中配置的bean对象
*** AnnotationConfigApplicationContext类
#+begin_src java
org.springframwor.context.annotation.AnnotationConfigApplicationContext
#+end_src
这个类也实现了ApplicationContext接口，注意类名包含了Annotation和config这两个单词，上面我们说过，bean的定义支持xml方式和注解方式，
当我们使用注解的方式定义bean的时候，就需要用这个容器来装载了，这个容器内部会解析注解来构建和管理需要的bean。

注解的方式相对xml方便一些，也是我们比较推荐的方式，后面我们会大量使用这种方式，具体会详解。
* xml中bean定义详解
** bean概念
被spring管理的对象统称为bean，我们程序中需要用到很多对象，我们将这些对象让spring去帮我们创建和管理，我们可以通过bean xml配置文件
告诉spring容器需要管理哪些bean,spring帮我们创建和组装好这些bean对象，spring内部将这些名称和具体的bean对象进行绑定，
然后spring容器可以通过这个的名称找对我们需要的对象，这个名称叫做bean名称，
在一个spring容器中需要是唯一的。
** bean xml配置文件格式
bean xml文件用于定义spring容器需要管理的bean，常见的格式如下：
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">

          <import resource="引入其他bean xml配置文件" />
          <bean id="bean标识" class="完整类型名称"/>
          <alias name="bean标识" alias="别名" />
  </beans>
#+end_src
beans是根元素，下面可以包含任意数量的import，bean，alias元素，下面我们对每个元素进行详解。
** bean元素详解
*** 作用
用来定义一个bean对象
*** 格式
#+begin_src xml
<bean id="bean唯一标识" name="bean名称" class="完整类型名称" factory-bean="工厂bean名称" factory-method="工厂方法"/>
#+end_src
** 名称和别名详解
*** 名称
每个bean都有一个名称，叫做bean名称，bean名称在一个spring容器中必须是唯一的，否则会报错，通过bean名称可以从spring容器中获取对应的bean对象。
*** 别名
**** 什么是别名
相当于人的外号一样，一个人可能有很多外号，当别人喊这个人的名称和外号的时候，都可以找到这个人。那么bean也是一样，也可以给bean起几个外号，
这个外号在bean中叫做bean的别名，spring容器允许使用者通过名称或者别名获取到对应的bean对象。
**** 别名定义规则
名称和别名可以通过bean元素中的id和name来定义，规则如下
1. 当id存在的时候，不管name有没有，取id为bean的名称。
2. 当id不存在的时候，此时需要看name，name的值可以通过 , ; 空格来分隔，最后会按照分隔符得到一个spring数组，数组的第一个元素作为bean的名称，
   其它的作为bean的别名。
3. 当id和name都存在的时候，id未bean名称，name用来定义多个别名
4. 当id和name都不指定的时候,bean名称自动生成，生成规则下面详细说明。
**** bean名称和别名的各种写法
#+begin_src xml
<!-- 通过id定义bean名称:user1 -->
<bean id="user1" class="com.example.UserModel/>

<!-- 通过name定义bean名称：user2 -->
<bean name="user2" class="com.example.UserModel"/>

<!-- id为名称，name为别名；bean名称：user3,1个别名：user3_1 -->
<bean name="user3" name="user3_1" class="com.example.UserModel"/>

<!-- id为名称：user4, 多个别名：user4_1,user4_2,user4_3,user4_4 -->
<bean id="user4" name="user4_1,user4_2;user4_3 user4_4" class="com.example.UserModel"/>

<!-- bean名称：user5, 别名：user5_1,user5_2,user5_3,user5_4 -->
<bean name="user5,user5_1,user5_2,user5_3,user5_4" class="com.example.UserModel"/>
#+end_src
java输出结果
#+begin_src java
public class Example {
  public static void main(String[] args) {
    //1.bean配置文件位置
    String beanXml = "classpath:/com/example/beans.xml";
    //2.创建ClassPathXmlApplicationContext容器，给容器指定需要加载的bean配置文件
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(beanXml);
    for (String beanName : Arrays.asList("user1", "user2", "user3", "user4","user5")) {
      //获取bean的别名
      String[] aliases = context.getAliases(beanName);
      System.out.println(String.format("beanName:%s,别名:[%s]", beanName,String.join(",", aliases)));
    }
    System.out.println("spring容器中所有bean如下：");
    //getBeanDefinitionNames用于获取容器中所有bean的名称
    for (String beanName : context.getBeanDefinitionNames()) {
      //获取bean的别名
      String[] aliases = context.getAliases(beanName);
      System.out.println(String.format("beanName:%s,别名:[%s]", beanName,String.join(",", aliases)));
    }
  }
}
#+end_src
***** id和name都未指定
当id和name都未指定的时候，bean名称和别名由spring自动生成。
****** bean名称为
bean的class的完整类名#编号

编号是从0开始的同种类型的没有定义名称的依次递增。
****** 别名为完整的类名
***** alias元素
alias元素也剋用来给某个bean定义别名，语法为：
#+begin_src xml
<alias name="需要定义别名的bean" alias="别名"/>
<!-- 例如 -->
<bean id="user6" class="com.javacode2018.lesson001.demo2.UserModel" />
<alias name="user6" alias="user6_1" />
<alias name="user6" alias="user6_2" />
#+end_src
** 通过import元素引入外部配置
当我们的系统比较大的时候，会分成很多模块，每个模块会对应一个bean xml文件，我们可以在一个总的bean xml中对其它bean xml进行汇总，相当于把多个bean xmln
内容合并到了一个里面，可以通过import元素引入其它bean配置文件。

语法：
#+begin_src xml
  <import resource="其它配置文件的位置"/>
  <!-- 例如 -->
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">

    <import resource="user.xml" />
    <import resource="order.xml" />

  </beans>
#+end_src

*

* 容器创建bean实例有多少种
** 通过反射调用构造方法创建bean对象
调用类的构造方法获取对应的bean实例，是使用最多的方式，这种方式只需要在xml bean元素中指定class属性,spring容器内部自动会自动调用该类型的构造方法来创建bean对象，将其放在容器中以供使用。
*** 语法
#+begin_src xml
  <bean id="bean名称" name="bean名称或别名" class="bean的完整类型名称">
    <constructor-arg index="0" value="bean的值" ref="引用的bean名称" />
    <constructor-arg index="1" value="bean的值" ref="引用的bean名称" />
    <constructor-arg index="2" value="bean的值" ref="引用的bean名称" />
    <constructor-arg index="3" value="bean的值" ref="引用的bean名称" />
    ......
    <constructor-arg index="4" value="bean的值" ref="引用的bean名称" />
  </bean>
#+end_src
+ constructor-arg: 用于指定构造方法参数的值
+ index: 构造方法中参数的位置，从0开始，依次递增
+ value: 指定参数的值
+ ref: 当插入的值为容器内其它bean的时候，这个值为容器中对应的bean的名称
** 通过静态工厂方法创建bean对象
我们可以通过创建静态工厂，内部提供一些静态方法来生成所需的对象，将这些静态方法创建的对象交给spring以供使用.
*** 语法
#+begin_src xml
  <bean id="bean名称" name="" class="静态工厂完整类名" factory-method="静态工厂方法">
    <constructor-arg index="0" value="bean的值" ref="引用的bean名称" />
    <constructor-arg index="1" value="bean的值" ref="引用的bean名称" />
    <constructor-arg index="2" value="bean的值" ref="引用的bean名称" />
    <constructor-arg index="3" value="bean的值" ref="引用的bean名称" />
  </bean>
#+end_src
+ class: 指定静态工厂完整的类名
+ factory-method: 静态工厂中的静态方法，返回需要的对象
+ constructor-arg: 用于指定静态方法参数的值，用法和上面介绍的构造方法一样
spring容器会自动调用静态工厂的静态方法获取指定的对象，将其放在容器中以供使用
** 通过实例工厂方法创建bean对象
让spring容器去调用某些对象的某些实例方法来生成bean对象放在容器中以供使用。
*** 语法
#+begin_src xml
  <bean id="bean名称" factory-bean="需要调用的实例对象bean名称" factory-method="bean对象中的方法">
    <constructor-arg index="0" value="bean的值" ref="引用的bean名称"></constructor-arg>
    <constructor-arg index="1" value="bean的值" ref="引用的bean名称"></constructor-arg>
    <constructor-arg index="2" value="bean的值" ref="引用的bean名称"></constructor-arg>
    <constructor-arg index="3" value="bean的值" ref="引用的bean名称"></constructor-arg>
    <constructor-arg index="4" value="bean的值" ref="引用的bean名称"></constructor-arg>
  </bean>
#+end_src
spring容器以 *factory-bean 的值为bean名称查找对应的bean对象，然后调用该对象中 *factory-method* 属性值指定的方法，将这个方法返回的对象作为当前的bean对象放在容器中以供使用。
** 通过FactoryBean创建bean对象
前面说到了BeanFactor接口，BeanFactory是spring容器的顶层接口，而这里要说的是FactoryBean，也是一个接口，这两个接口很容器混淆，FactoryBean可以容器spring容器通过这个接口
的实现来创建我们需要的bean对象。

FactoryBean接口源码：
#+begin_src java
  public interface FactoryBean<T> {
    /**
     * 返回创建好的对象
    */
    @Nullable
    T getObject() throws Exception;
    /**
    * 返回需要创建的对象的类型
    */
    @Nullable
    Class<?> getObjectType();
    /**
    * bean是否是单例的
    */
    default boolean isSingleton() {
      return true;
    }
  }
#+end_src
接口中有三个方法，前面两个方法需要我们去实现，getObject方法内部由开发者自己去实现对象的创建，然后将创建好的对象返回给spring容器，
getObjectType需要指定我们创建的bean类型；最后一个方法isSingleton表示通过这个接口创建的对象是否是单例的，如果返回false,那么每次
从容器中获取对象的时候都会调用这个接口的getObject()去生成bean对象。
*** 语法
#+begin_src xml
  <bean id="bean名称" class="FactoryBean接口实现类" />
#+end_src
*** 案例
#+begin_src java
  public class UserFactoryBean implements FactoryBean<UserModel> {

    int count = 1;

    @Nullable
    @Override
    public UserModel getObject() throws Exception { // @1
      UserModel userModel = new UserModel();
      userModel.setName("我是通过FactoryBean创建的第" + count + "对象"); // @4
      return userModel;
    }

    @Nullable
    @Override
    public Class<?> getObjectType() {
      return UserModel.class; //@2
    }

    @Override
    public boolean isSingleton() {
      return true; //@3
    }
  }
#+end_src
+ @1: 返回了一个创建好的usermodel对象
+ @2： 返回对象的Class对象
+ @3： 返回true，表示创建的对象是单例的，那么我们每次从容器中获取这个对象的时候都是同一个对象
+ @4： 此处用到了一个count,通过这个可以看出isSingleton不同返回值的时候从容器获取bean是否是同一个。
**** bean xml配置
#+begin_src xml
  <!-- 通过FactoryBean 创建UserModel对象 -->
  <bean id="createByFactoryBean" class="com.example.UserFactoryBean"/>
#+end_src

* bean作用域scope详解
应用中，有时候我们需要一个对象在整个应用中只有一个，有些对象希望每次使用的时候都重新创建一个，spring对我们这种需求也提供了支持，在spring中这个叫做bean的作用域，
xml中定义bean的时候，可以通过scope属性指定bean的作用域；
#+begin_src xml
  <bean id="" class="" scope="作用域" />
#+end_src
** singleton
当scope的值设置为singleton的时候，整个spring容器只会存在一个bean实例，通过容器多次查找bean的时候(调用BeanFactory的getBean方法或者bean之间注入依赖的bean对象的时候)，
返回的都是同一个bean对象，singleton是scope的默认值，所以spring容器中默认创建的bean对象是单例的，通常spring容器在启动的时候，会将scope为singleton的bean创建好放在容器中
(有个特殊的情况，当bean的lazy为true的时候，表示懒加载，那么使用的时候才会创建),用的时候直接返回。
*** 案例
**** bean xml配置
#+begin_src xml
  <!-- 单例bean，scope设置为singleton -->
  <bean id="singletonBean" class="com.demo4.BeanScopeModel" scope="singleton">
    <constructor-arg index="0" value="singleton"/>
  </bean>
#+end_src
**** BeanScopeModel代码
#+begin_src java
  public class BeanScopeModel {
      public BeanScopeModel(String beanScope) {
          System.out.println(String.format("create BeanScopeModel,{sope=%s},{this=%s}", beanScope, this));
      }
  }
#+end_src
上面构造方法中输出了一段文字，是从容器中获取bean的时候创建的还是容器启动的时候创建的。（启动时）
*** 单例bean使用注意
单例bean是整个应用共享的，所以需要考虑到线程安全的问题，之前在玩springMVC的时候，springMVC中的controller默认是单例的，有些开发者在controller中创建了一些变量，那么这些变量实际上就变成共享的了，
controller可能会被很多线程同时访问，这些线程并发去修改controller中的共享变量，可能会出现数据错乱的问题，所以使用的时候需要特别注意。

** prototype
如果scope被设置成prototype类型了，表示这个bean是多例的，通过容器每次获取的bean都是不同的实例，每次获取都会重新创建一个bean实例对象。
*** 案例
**** bean xml配置
#+begin_src xml
  <!-- 多例bean，scope被设置为prototype -->
  <bean id="prototypeBean" class="com.demo4.BeanScopeModel" scope="prototype">
    <constructor-arg index="0" value="prototype"/>
  </bean>
#+end_src
*** 多例bean使用注意
多例bean每次获取的时候都会重新创建,如果这个bean比较复杂，创建时间比较长，会影响系统的性能，这个地方需要注意
** spring web容器环境独有的三个作用域
*** request
当一个bean的作用域为request时，表示再一次http请求中，一个bean对应一个实例；对每个http请求都会创建一个bean实例,request结束的时候，
这个bean也就结束了，request作用域用在spring容器的web环境中，这个以后讲springMVC的时候就会说,spring中有个web容器接口webapplicationcontext，
这个里面对request作用域提供了支持,配置方式如下：
#+begin_src xml
  <bean id="" class="" scope="request" />
#+end_src
*** session
这个和request类似，也是用在web环境中，session级别共享的bean,每个会话对应一个bean实例，不同的session对应不同的bean实例，springMVC中会提到
#+begin_src xml
<bean id="" class="" scope="session" />
#+end_src
*** application
全局web应用级别的作用域，也是web环境中使用，一个web应用程序对应一个bean实例，通常情况下和singleton效果类似，不过也有不一样的地方，singleton
是每个spring容器中只有一个bean实例，一般我们的程序只有一个spring容器，但是，一个应用程序中可以创建多个spring容器，不同的容器中可以存在同名的bean，
但是scope=application的时候，不管应用中有多少个spring容器，这个应用中同名的bean只有一个。
** 自定义作用域的实现（自定义scope）
*** 实现scope接口
#+begin_src java
public interface Scope {
  /**
  * 返回当前作用域中name对应的bean对象
  * name：需要检索的bean的名称
  * objectFactory：如果name对应的bean在当前作用域中没有找到，那么可以调用这个ObjectFactory来创建这个对象
  **/
  Object get(String name, ObjectFactory<?> objectFactory);
  /**
  * 将name对应的bean从当前作用域中移除
  **/
  @Nullable
  Object remove(String name);
  /**
  * 用于注册销毁回调，如果想要销毁相应的对象,则由Spring容器注册相应的销毁回调，而由自定义作用域选择是不是要销毁相应的对象
  */
  void registerDestructionCallback(String name, Runnable callback);
  /**
  * 用于解析相应的上下文数据，比如request作用域将返回request中的属性。
  */
  @Nullable
  Object resolveContextualObject(String key);
  /**
  * 作用域的会话标识，比如session作用域将是sessionId
  */
  @Nullable
  String getConversationId();
}
```
*** 将自定义的scope注册到容器
需要调用 *org.springframework.beans.factory.ConfigurableBeanFactory#registerScope* 的方法，看一下这个方法的声明。
#+begin_src java
/**
*向容器中注册自定义的scope
*scopeName: 作用域名称
*scope:作用域对象
**/
void registerScope(String scopeName, Scope scope);
#+end_src
*** 使用自定义的作用域
定义bean的时候，指定bean的scope属性为自定义的作用域名称。
*** 实现
实现一个线程级别的bean作用域，同一个线程中同名的bean是同一个实例，不同的线程中的bean是不同的实例，
**** 需求中要求bean在线程中是贡献的，所以我们可以通过ThreadLocal来实现，ThreadLocal可以实现线程中数据的共享。
**** 代码ThreadScope.java
#+begin_src java
  public class ThreadScope implements Scope {
      public static final String THREAD_SCOPE = "thread"; //@1
      private ThreadLocal<Map<String,Ojbect>> beanMap = new ThreadLocal() {
              @override
              protected Object initiaValue() {
                  return new HashMap<>();
              }
          };
      @Override
      public Object get(String name, ObjectFactory<?> objectFactory) {
          Object bean = beanMap.get().get(name);
          if (Objects.isNull(bean)) {
              bean = objectFactory.getObject();
              beanMap.get().put(name, bean);
          }
          return bean;
      }
      @Nullable
      @Override
      public Object remove(String name) {
          return this.beanMap.get().remove(name);
      }
      @Override
      public void registerDestructionCallback(String name, Runnable callback) {
          //bean作用域范围结束的时候调用的方法，用于bean清理
          System.out.println(name);
      }
      @Nullable
      @Override
      public Object resolveContextualObject(String key) {
          return null;
      }
      @Nullable
      @Override
      public String getConversationId() {
          return Thread.currentThread().getName();
      }
  }
#+end_src
@1: 定义了作用域的名称为一个常量thread，可以在定义bean的时候给scope使用。
**** BeanScopeModel.java
#+begin_src java
  public class BeanScopeModel {
      public BeanScopeModel(String beanScope) {
          System.out.println(String.format("线程:%s,create BeanScopeModel,{sope=%s},{this=%s}", Thread.currentThread(), beanScope, this));
      }
  }
#+end_src
上面的构造方法中会输出当前线程的信息，到时候可以看到创建bean的线程。
**** 配置文件 beans-thread.xml
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">
    <!-- 自定义的bean -->
    <bean id="threadBean" class="com.javacode2018.lesson001.demo4.BeanScopeModel" scope="thread">
      <constructor-arg index="0" value="thread"/>
    </bean>
  </beans>
#+end_src
注意上面的scope是我们自定义的，值为thread
**** 测试用例
#+begin_src java
  public class ThradScopeTest{
      public static void main(String[] args) throws InterruptedException {
          // 配置文件位置
          String beanXml = "classpath:/com/example/beans-thread.xml";
          // 手动创建容器
          ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(){
                  @Override
                  protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
                      // 向容器中注册自定义的scope
                      beanFactory.registerScope(ThreadScope.THREAD_SCOPE, new ThreadScope()); // @1
                      supper.postProcessBeanFactory(beanFactory);
                  }
              };
          // 读取配置文件位置
          context.setConfigLocation(beanXml);
          // 启动容器
          context.refresh();
          // 使用容器获取bean
          for (int i = 0; i < 2; i++) { // @2
              new Thread(() -> {
                      System.out.println(Thread.currentThread() + "," + context.getBean("threadBean"));
                      System.out.println(Thread.currentThread() + "," + context.getBean("threadBean"));
              }).start();
              TimeUnit.SECONDS.sleep(1);
          }
      }
  }
#+end_src
** 总结
1. spring容器自带的有两种作用域，分别是singleton和prototyp,还有三种分别是 spring web 容器环境中才支持的request,session, application
2. singleton是spring容器默认的作用域，一个spring容器中同名的bean实例只有一个，多次获取得到的是同一个bean;单线程的bean需要考虑线程安全问题。
3. prototype是多例的，每次从容器中获取同名的bean，都会重新创建一个；多例bean使用的时候需要考虑创建bean对性能的影响。
4. 一个应用中可以有多个spring容器
5. 自定义scope 3个步骤，实现Scope接口，将实现类注册到spring容器，使用自定义的sope

* 依赖注入之手动注入
** 什么是依赖
通常情况下，系统中类和类之间是有依赖关系的，如果一个类对外提供的功能需要通过调用其它类的方法来实现的时候，说明这两个类之间存在依赖关系。
*** 依赖对象的初始化方式
+ 通过构造器设置依赖对
+ 通过set方法设置依赖对象
** spring依赖注入
*** 通过构造器注入
构造器的参数就是被依赖的对象，狗在其注入又分为3种注入方式：
+ 根据构造器参数索引注入
+ 根据构造器参数类型注入
+ 根据构造器参数名称注入
**** 根据构造器参数索引注入
***** 用法
#+begin_src xml
  <bean id="" class="">
    <constructor-arg index="0" value="上海"></constructor-arg>
    <constructor-arg index="1" value="沈阳"></constructor-arg>
    <constructor-arg index="2" value="武汉"></constructor-arg>
  </bean
#+end_src
+ constructor-arg 用户指定构造器的参数
+ index:构造器参数的位置
+ value:构造器参数的值，value只能用来给简单的参数设置值，value对应的属性类型只能为byte,int,long,float,double,boolean,
  Byte,Long,Float,Double,枚举,spring容器内部注入的时候会将value的值转换为对应的类型
***** 优缺点
1. 参数位置的注入对参数的顺序有很强的依赖性，若构造函数的参数位置被人调整过，会导致注入出错
2.通常情况下，不建议去代码中修改构造函数，如果愮新增参数的，可以新增一个构造函数来实现，这算是一个扩展，不会影响目前已有的功能。
**** 根据构造器参数类型注入
***** 用法
#+begin_src xml
  <bean id="" class="">
    <constructor-arg type="参数类型" value="参数值"></constructor-arg>
    <constructor-arg type="参数类型" value="参数值"></constructor-arg>
    <constructor-arg type="参数类型" value="参数值"></constructor-arg>
  </bean>
#+end_src
+ constructor-arg:用户指定构造器的参数
+ type:构造器参数的完整类型，如：java.lang.String,int,double
+ value:构造器参数的值，value只能用来给简单的类型设置值
***** 有缺点
实际上按照参数位置或者按照参数的类型注入，都有一个问题，很难通过bean的配置文件知道这个参数是对应UserModel种的哪个属性的，代码的可读性不好，
比如我想知道这每个参数对应的UserModel中的哪个属性，必须要去看UserModel源码。

**** 根据构造器参数名称注入
***** 用法
#+begin_src xml
  <bean id="" class="">
    <constructor-arg name="参数类型" value="参数值"></constructor-arg>
    <constructor-arg name="参数类型" value="参数值"></constructor-arg>
    <constructor-arg name="参数类型" value="参数值"></constructor-arg>
  </bean>
#+end_src
+ constructor-arg:用户指定构造器的参数
+ name:构造参数名称
+ value:构造器参数的值，value只能用来给简单的类型设置
****** 关于方法参数名称的问题
java通过反射的方式可以获取到方法的参数名称，不过源码中的参数通过编译之后会变成class对象，通常情况下源码变成class文件之后，
参数的真实名称会丢失，参数的名称会变成arg0，arg1,arg2,这样的，和实际的参数名称不一样了， *如果需要将源码中的参数名称保留在编译之后的class文件中，编译
的时候需要用到下面的命令*
#+begin_src shell
  javac -parameters java源码
#+end_src
但是我们难以保证编译代码的时候，操作人员一定会带上 *-parameters* 参数，所以方法的参数可能在class文件中会对视，导致反射获取到的参数名称和实际参数名称不符，
这个需要我们先了解一下。

参数名称可能不稳定的问题，spring提供了解决方案，通过Constructorproperties注解来定义参数的名称，将这个注解加在构造方法上面：
#+begin_src java
  @ConstructorProperties({"第一个参数名称", "第二个参数的名称",..."第n个参数的名称"})
  public 类名(String p1, String p2...,参数n) {}
#+end_src
*** setter注入
通常情况下，我们的类都是标准的javabean,javabean类特点：
+ 属性都是private级别的
+ 属性通常情况下通过一组setter，getter方法来访问
+ setter方法，以set开头后跟首字母大写的属性名，如： *setUserName* ,简单属性一般只有一个方法参数，方法返回值通常为void;
+ getter方法，一般属性以get开头，对于boolean类型一般以is开头，后跟首字母大写的属性名，如： *getUserName,isOk*;

spring对符合javabean特点的类,提供了setter方法的注入，会调用对应属性的setter方法将被以来的对象注入进去。
**** 用法
#+begin_src xml
  <bean id="" class="">
    <property name="属性名称" value="属性值"></property>
    <property name="属性名称" value="属性值"></property>
    <property name="属性名称" value="属性值"></property>
    <property name="属性名称" value="属性值"></property>
  </bean>
#+end_src
+ property: 用于对属性的值进行配置，可以有多个
+ name: 属性的名称
+ value：属性的值
**** 优缺点
setter注入相对于构造函数注入要灵活一些，构造函数需要指定对应构造函数中所有参数的值，而setter注入的方式没有这种限制，不需要对所有的属性
都进行注入，可以按需进行注入

*** 注入特殊类型的对象
**** 注入容器中的bean
注入容器中的bean的有两种写法
+ ref属性方式
+ 内置bean的方式
***** ref属性方式
将上面介绍的constructor-arg或者property元素的value属性名称替换为ref,ref属性的值为容器中其它bean的名称

构造器方式，将value替换为ref
#+begin_src xml
  <constructor-arg ref="需要注入的bean的名称" />
#+end_src
setter方式，将value替换为ref
#+begin_src xml
  <property name="属性名称" ref="需要注入的bean名称" />
#+end_src
***** 内置bean的方式
构造器方式：
#+begin_src xml
  <constructor-arg
      <bean class="" />
  </constructor-arg>
#+end_src
setter方式：
#+begin_src xml
  <property>
    <bean class="" />
  </property>
#+end_src
*** 其它常见类型注入详解
**** 注入java.util.List(List元素)
#+begin_src xml
  <list>
    <value>spring</value>

    <ref bean="bean名称"/>

    <list></list>

    <bean></bean>

    <array></array>

    <map></map>

  </list>
#+end_src
**** 注入java.util.Set(Set元素)
#+begin_src xml
  <set>
    <value>spring</value>

    <ref bean="bean名称"/>

    <list></list>

    <bean></bean>

    <array></array>

    <map></map>

  </set>
#+end_src
**** 注入java.util.Map(Map元素)
#+begin_src xml
  <map>
    <entry key="aaa" value="30" key-ref="key引用的bean名称" value-ref="value引用的bean名称"></entry>
    <entry>
      <key>
        value对应的值，可以为任意类型
      </key>
      <value>
        value对应的值，可以为任意类型
      </value>
    </entry>
  </map>

#+end_src
**** 注入数组(array数组)
#+begin_src xml
  <array>
    数组中的元素
  </array>
#+end_src
**** 注入java.util.Properties(Props元素)
Properties类相当于键值都是String类型的Map对象，使用props进行注入，如下：
#+begin_src xml
  <props>
    <prop key="key1">value1</prop>
    <prop key="key2">value2</prop>
    <prop key="key3">value3</prop>
  </props>
#+end_src
**** 案例
diOtherTypeModel.java
#+begin_src java
  public class DiOtherTypeModel {
      private List<String> list1;
      private Set<UserModel> set1;
      private Map<String, Integer> map1;
      private int[] array1;
      private Properties properties1;
      public List<String> getList1() {
          return list1;
      }
      public void setList1(List<String> list1) {
          this.list1 = list1;
      }
      public Set<UserModel> getSet1() {
          return set1;
      }
      public void setSet1(Set<UserModel> set1) {
          this.set1 = set1;
      }
      public Map<String, Integer> getMap1() {
          return map1;
      }
      public void setMap1(Map<String, Integer> map1) {
          this.map1 = map1;
      }
      public int[] getArray1() {
          return array1;
      }
      public void setArray1(int[] array1) {
          this.array1 = array1;
      }
      public Properties getProperties1() {
          return properties1;
      }
      public void setProperties1(Properties properties1) {
          this.properties1 = properties1;
      }
      @Override
      public String toString() {
          return "DiOtherTypeModel{" +
              "list1=" + list1 +
              ", set1=" + set1 +
              ", map1=" + map1 +
              ", array1=" + Arrays.toString(array1) +
              ", properties1=" + properties1 +
              '}';
      }
  }
#+end_src
diOtherType.xml
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">
    <bean id="user1" class="com.example.UserModel"/>
    <bean id="user2" class="com.example.UserModel"/>
    <bean id="diOtherType" class="com.example.DiOtherTypeModel">
      <!-- 注入java.util.List对象 -->
      <property name="list1">
        <list>
          <value>Spring</value>
          <value>SpringBoot</value>
        </list>
      </property>
      <!-- 注入java.util.Set对象 -->
      <property name="set1">
        <set>
          <ref bean="user1"/>
          <ref bean="user2"/>
          <ref bean="user1"/>
        </set>
      </property>
      <!-- 注入java.util.Map对象 -->
      <property name="map1">
        <map>
          <entry key="路人甲Java" value="30"/>
          <entry key="路人" value="28"/>
        </map>
      </property>
      <!-- 注入数组对象 -->
      <property name="array1">
        <array>
          <value>10</value>
          <value>9</value>
          <value>8</value>
        </array>
      </property>
      <!-- 注入java.util.Properties对象 -->
      <property name="properties1">
        <props>
          <prop key="key1">java高并发系列</prop>
          <prop key="key2">mybatis系列</prop>
          <prop key="key3">mysql系列</prop>
        </props>
      </property>
    </bean>
  </beans>
#+end_src
** 总结
1. 本文主要讲解了xml中bean的依赖注入，都是采用硬编码的方式进行注入的这种算是手动的方式
2. 注入普通类型通过value属性或者value元素设置注入的值；注入对象如果是容器中的其它bean时候，需要使用ref属性，或者ref元素或者内置bean元素的方式
3. 还介绍了其它几种类型List,Set,Map,数组,properties类型的注入。

* 依赖注入之自动注入(autowire)详解
** 手动注入不足
所谓手动注入就是指在xml中采用硬编码的方式来配置注入的对象，比如通过构造器注入或者set方法注入，这些注入的方式都存在不足。
+ 如果需要注入的对象比较多，比如A类中有几十个属性是不是需要写几十个，此时配置文件中的代码量暴增。
+ 如果A类新增或删除一些依赖，还需要手动去调整bean xml中的依赖配置信息，否则会报错
+ 总的来说就是不利于维护和扩展

为了解决上面的问题，spring为我们提供了更加强大的功能，自动注入
** Class.isAssignableFrom方法
*** 用法
isAssignableFrom方法是Class类中的一个方法，看一下这个方法的定义
#+begin_src java
  public native boolean isAssignableFrom(Class<?> cls)
#+end_src
用法如下：
#+begin_src java
  cl.isAssignableFrom(c2);
#+end_src
用来判断C2和c1是否相等，或者c2是否是c1的子类。
** 自动注入
自动注入是采用约定大于配置的方式来实现的，程序和spring容器之间约定好，遵守某一种都认同的规矩，来实现自动注入。

xml中可以在bean元素中通过 *autowire* 属性来设置自动注入的方式：
#+begin_src xml
  <bean id="" class="" autowire="byType|byName|constructor|default" />
#+end_src
+ byName: 按照名称进行注入
+ byType: 按照类型进行注入
+ constructor: 按照构造方法进行注入
+ default: 按照默认注入方式
*** 按照名称进行注入(byName)
**** 用法
#+begin_src xml
<bean id="" class="x类" autowire="byName"
#+end_src
spring容器会按照set属性的名称去容器中查找同名的bean对象，然后将查找到的对象通过set方法注入到对应的bean中，未找到对应的名称的bean对象
则set方法不进行注入。

需要注入的set属性的名称和被注入的bean的名称必须保持一致。
**** 优缺点
按照名称进行注入的时候，要求名称和set属性的名称必须同名，相对于硬编码的方式注入，确实节省了不少的代码。
*** 按照类型进行自动注入
**** 用法
#+begin_src xml
  <bean id="" class="x类" autowire="byType"
#+end_src
spring容器会遍历x类中的所有set方法，会在容器中查找和set参数类型相同的bean对象，将其通过set方法进行注入，未找到对应类型的bean对象
则set方法不进行注入。

*需要注入的set属性的类型和被注入的bean的类型需要满足isAssignableFrom关系*

按照类型自动装配的时候，如果按照类型找到了多个符合条件的bean，系统就会报错。

*set方法的参数如果是下面的类型或者下面类型的数组的时候，这个set方法会被跳过注入* ：
#+begin_src java
  Object;
  Boolean;
  boolean;
  Byte;
  byte;
  Character;
  char;
  Double;
  double;
  Float;
  float;
  Integer;
  int;
  Long;
  long;
  Short;
  short;
  Enum;
  CharSequence;
  Number;
  Date;
  java.time.temportal.Temporal;
  java.net.URI;
  java.util.Locate.lang.Class;
#+end_src
**** 优缺点
相对于手动注入，节省了不少代码，新增或者删除属性，只需要增加或减少对应的set方法就可以了，更容易扩展了。

*** 注入类型匹配的所有bean(*重点*)
**** 按照类型注入还有两个比较牛逼的用法
+ 一个容器中满足某种类型的bean可以有很多个，将容器中某种类型中的所有bean,通过set方法注入
  给一个java.util.List<需要注入的Bean的类型或者其父类型或者其接口对象>
+ 将容器中某种类型中的所有bean,通过set方法注入给java.util.Map<String,需要注入的Bean的类型或者其父类型或者其接口对象>
**** 案例
DiAutowireByTypeExtend.java
#+begin_src java
  import java.util.List;
  import java.util.Map;
  /**
   ,*满足条件的bean注入到集合中(重点)
   ,*/
  public class DiAutowireByTypeExtend {
      // 定义了一个接口
      public interface IService1 {}

      public static class BaseServie{
          private String desc;
          public String getDesc() {
              return desc;
          }
          public void setDesc(String desc) {
              this.desc = desc;
          }
          @overide
          public String toString(){
              return "BaseService{desc=" + desc + "}";
          }
      }
      // Service1实现了IService1接口
      public static class Service1 extends BaseService implements IService1 {}

      // Service2实现了IService1接口
      public static class Service2 extends BaseService implements IService1 {}

      private List<IService1> serviceList; //@1
      private List<BaseService> baseServiceList; //@2
      private Map<String,IService1> serviceMap; // @3
      private Map<String,BaseService> baseServiceMap; //@4

      public List<IService1> getServiceList() {
          return serviceList;
      }

      public void setServiceList(List<IService1> serviceList) { // @5
          this.serviceList = serviceList;
      }

      public List<BaseService> getBaseServiceList() {
          return baseSreviceList;
      }

      public void setBaseServiceList(List<BaseService> baseServiceList) { //@6
          this.baseServiceList = baseServiceList;
      }
      public Map<String, IService1> getService1Map() {
          return service1Map;
      }
      public void setService1Map(Map<String, IService1> service1Map) {//@7
          this.service1Map = service1Map;
      }
      public Map<String, BaseServie> getBaseServieMap() {
          return baseServieMap;
      }
      public void setBaseServieMap(Map<String, BaseServie> baseServieMap) {//@8
          this.baseServieMap = baseServieMap;
      }
      @Override
      public String toString() { //9
          return "DiAutowireByTypeExtend{" +
              "serviceList=" + serviceList +
              ", baseServieList=" + baseServieList +
              ", service1Map=" + service1Map +
              ", baseServieMap=" + baseServieMap +
              '}';
      }
  }
#+end_src
+ @1,@2,@3,@4 定义了四个属性，都是反省类型的，都有对应的set方法。
+ @5： 参数类型是List<BaseService>,这个集合中元素的类型是BaseService,spring会找到容器中所有满足BaseService.isAssignableFrom(bean的类型)的
  bean列表，将其通过@5的set方法进行注入。
+ @6： 通@5代码
+ @7： 这个参数类型是一个map了，map的key是String类型，value是IService类型，spring容器会将所有满足IService1类型的bean找到，
  按照name->bean对象这种方式丢到一个map中，然后调用@7的set方法进行注入，最后注入的这个map就是bean的名称和bean对象进行映射的一个map对象。
+ @8： 通@7代码
+ @9： 重写了toString方法，

*** 按照构造函数进行自动注入
**** 用法
#+begin_src xml
  <bean id="" class="x类" autowire="constructor" />
#+end_src
spring会扎到x类中所有的构造方法(一个类可能有多个构造方法)，然后将这些构造方法进行排序（先按照修饰符进行排序，public在前面，其它的在后面，如果修饰符
一样，会按照构造函数参数数量倒叙，也就是采用贪婪的模式进行匹配，spring容器会尽量多注入一些需要的对象）得到一个构造函数列表，会轮询这个构造器列表，
判断当前构造器所有参数是否在容器中都可以找到匹配的bean对象，如果可以找到就使用这个构造器进行注入，如果不能找到，那么就会跳过这个构造器，继续采用同样的方式
匹配下一个构造器，知道找到一个何时的为止。
*** autowire=default
**** 用法
bean xml 的根元素为beans,注意根元素有个default-autowire属性，这个属性可选值有 *no|byName|byType|constructor|default* ,这个属性可以批量设置当前文件中所有bean的自动注入的方式，
bean元素中如果省略了autowire属性，那么会取default-autowire的值作为其autowire的值，而每个bean元素还可以单独设置自己的autowire覆盖default-autowire的配置，如下：
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd"
         default-autowire="byName">
  </beans>
#+end_src
**

** 总结
+ xml中手动注入存在的不足，可以通过自动注入的方式来解决
+ 按照类型注入中有个比较重要的是注入匹配类型所有的bean，可以将某种类型所有的bean注入给一个List对象，可以将某种类型的所有bean按照bean名称->bean对象
  的映射方式注入给一个Map对象，这种方法比较重要，用途比较大。
+ spring中还有其它自动注入的方式。

* depend-on
干预bean的创建和销毁的顺序
** 无任何依赖bean创建和销毁顺序
| bean定义顺序 | 创建顺序 | 销毁顺序 |
|--------------+----------+----------|
| bean3        | bean3    | bean1    |
| bean2        | bean2    | bean2    |
| bean1        | bean1    | bean3    |

+ bean对象的创建顺序和bean xml中定义顺序一致
+ bean销毁的顺序和bean xml中定义的顺序相反
** 通过构造器强依赖bean创建和销毁顺序
依赖关系是bean3->bean2->bean1
| bean定义顺序 | 依赖顺序（下面依赖上面的） | 创建顺序 | 销毁顺序 |
|--------------+----------------------------+----------+----------|
| bean3        | bean1                      | bean1    | bean3    |
| bean2        | bean2                      | bean2    | bean2    |
| bean1        | bean3                      | bean3    | bean1    |
+ bean对象的创建顺序和bean依赖的顺序一致
+ bean销毁的顺序和bean创建的顺序相反
** 通过depend-on干预bean创建和销毁顺序
上面看到了，对于无依赖的bean，通过定义的顺序确实可以干预bean的创建顺序，通过强依赖也可以干预bean的创建顺序。

那么如果xml中定义的bean特别多，而有些bean之间也没有强依赖关系，此时如果想去调整bean的创建和销毁顺序，得去调整xml中bean的定义顺序，或者去加强依赖，
这样是非常不好的，spring中可以通过 *depend-on* 来解决这些问题，在不调整bean的定义顺序和强加依赖的情况下，可以通过 *depend-on* 属性来设置当前bean的依赖于
哪些bean,那么可以保证depend-on指定的bean在当前bean之前创建好，销毁的时候在当前bean之后进行销毁。

*** depend-on使用方式：
#+begin_src xml
  <bean id="bean1" class="" depend-on="bean2,bean3;bean4" />
#+end_src
depend-on: 设置当前bean依赖的bean名称，可以指定多个，多个之间可以用 *, ; 空格*  进行分割，上面不管bean2,bean3,bean4在任何地方定义，都可以确保在bean1创建
之前，会先将bean2,bean3,bean4创建好，表示bean1依赖于这三个bean,可能bean1需要用到bean2,bean3,bean4中生成的一些资源或者其它功能等，但是又没有强制去在
bean1类中通过属性定义强依赖的方式去依赖于bean2,bean3,bean4,当然销毁的时候也会先贤惠当前bean,再去销毁被依赖的bean,即先销毁bean1,再去销毁depend-on中指定的bean。


** 总结
1. 无依赖的bean创建顺序和定义顺序一致，销毁顺序刚好相反
2. 通过构造器强依赖的bean，会先创建构造器参数中对应的bean,然后才会创建当前bean,销毁顺序刚好相反
3. depend-on可以指定当前bean依赖的bean,通过这个可以确保depend-on指定的bean在当前bean之前先创建好，销毁顺序刚好相反
* primary可以解决什么问题？
** 问题提出
当spring容器中定义了多个bean，分别是serviceA和serviceB......,这两个bean对象都实现了IService接口，此时想从容器中获取Service接口对应的bean，
此时容器中有多个候选者（servceA,serviceB,serviceC.....）满足我们的需求，此时spring容器不知道如何选择，到底是返回哪一个，spring懵了，就会报错。
** 解决方案
spring中可以通过bean元素的primary这个属性来解决问题，可以通过这个属性来指定当前bean为主要候选者，当容器中查询一个bean的时候，如果容器中有多个后选者匹配的时候，
此时spring会返回主要的后选者。
** 示例：
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">

    <bean id="serviceA" class="com.demo8.PrimaryBean$ServiceA" primary="true"/>
    <bean id="serviceB" class="com.demo8.PrimaryBean$ServiceA"/>

  </beans>
#+end_src
* autowire-candidate属性
解决自动注入时，出现多个相同类型的类，无法注入问题

设置某个bean是否在自动注入的时候是否为作为候选bean，通过bean元素的autowire-candidate属性来配置。
* lazy-init: bean延迟初始化
** bean初始化两种方式
+ 实时初始化
+ 延迟初始化
*** bean实时初始化
在容器启动过程中被创建组装好的bean，称为实时初始化的bean，spring中默认定义的bean都是实时初始化的bean，这些bean默认都是单例的，在容器启动过程中会被创建好，
然后放在spring容器中以供使用
**** 优点
1. 更早发下bean定义的错误：实时初始化的bean如果定义有问题，会在容器启动过程中抛出异常，让开发者快速发现问题。
2. 查找bean更快：容器启动完毕之后，实时初始化的bean已经完全创建好了，此时被缓存在spring容器中，当我们需要使用的时候，容器直接
  返回就可以了，速度是非常快的。
*** bean延迟初始化
实时初始化的bean都会在容器启动过程中创建好，如果程序中定义的bean非常多，并且有些bean创建的过程中比较耗时的时候，会导致系统消耗的资源比较多，
并且会让整个启动时间比较长。

针对以上问题，spring对这些问题提供了解决方案: *bean延迟初始化* 。

所谓延迟初始化，就是和实时初始化刚好相反，延迟初始化的bean在容器启动过程不会创建，而是需要的时候才会去创建，那么bean什么时候会被使用？
1. 被其它bean作为依赖进行注入的时候,比如通过property元素的ref属性进行引用，通过构造器注入，通过sett注入，通过自动注入，这些都会导致被依赖bean的创建。
2. 开发者自己写代码向容器中查找bean的时候，如调用容器的getBean方法获取bean.
**** 延迟bean的配置
#+begin_src xml
<bean lazy-init="true/false" />
#+end_src
* 使用继承简化bean的配置(abstract & parent)
** 案例引入
ServiceA.java
#+begin_src java
  public class ServiceA{}
#+end_src
ServiceB.java
#+begin_src java
  public class ServiceB {
      private String name;
      private ServiceA serviceA;
      public String getName() {
          return name;
      }
      public void setName(String name) {
          this.name = name;
      }
      public ServiceA getServiceA() {
          return serviceA;
      }
      public void setServiceA(ServiceA serviceA) {
          this.serviceA = serviceA;
      }
      @Override
      public String toString() {
          return "ServiceB{" +
              "name='" + name + '\'' +
              ", serviceA=" + serviceA +
              '}';
      }
  }
#+end_src
ServiceC.java
#+begin_src java
  public class ServiceC {
      private String name;
      private ServiceA serviceA;
      public String getName() {
          return name;
      }
      public void setName(String name) {
          this.name = name;
      }
      public ServiceA getServiceA() {
          return serviceA;
      }
      public void setServiceA(ServiceA serviceA) {
          this.serviceA = serviceA;
      }
      @Override
      public String toString() {
          return "ServiceB{" +
              "name='" + name + '\'' +
              ", serviceA=" + serviceA +
              '}';
      }
  }
#+end_src
beanExtend.xml
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">
    <bean id="serviceA" class="com.demo12.ServiceA"/>
    <bean id="serviceB" class="com.demo12.ServiceB">
      <property name="name" value="·Java1"/>
      <property name="serviceA" ref="serviceA"/>
    </bean>
    <bean id="serviceC" class="com.demo12.ServiceB">
      <property name="name" value="Java2"/>
      <property name="serviceA" ref="serviceA"/>
    </bean>
  </beans>
#+end_src
BeanExtendTest.java
#+begin_src java
  public class BeanExtendTest {
      @Test
      public void normalBean() {
          String beanXml ="classpath:/com/demo12/normalBean.xml";
          ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(beanExtend.xml);
          System.out.println("serviceB:" + context.getBean(ServiceB.class));
          System.out.println("serviceC:" + context.getBean(ServiceC.class));
      }
  }
#+end_src
运行结果为：
#+begin_src shell
  serviceB:ServiceB{name='Java1',serviceA=com.javacode2018.demo12.ServiceA@222114ba}
  serviceC:ServiceC{name='Java2',serviceA=com.javacode2018.demo12.ServiceA@222114ba}
#+end_src
** 通过继承优化代码
上面xml中有两个bean，serviceB和serviceC,这两个bean需要注入的属性值是一样的，都需要注入name和serviceA这两个属性，并且两个属性的值
也一样，我们可以将上面的代码抽取出来，通过spring中继承的方式来做到代码的重用。

xml更改如下：
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">
    <bean id="serviceA" class="com.demo12.ServiceA"/>
    <bean id="baseService" abstract="true">
      <property name="name" value="Java1"/>
      <property name="serviceA" ref="serviceA"/>
    </bean>
    <bean id="serviceB" class="com.demo12.ServiceB" parent="baseService"/>
    <bean id="serviceC" class="com.demo12.ServiceC" parent="baseService"/>
  </beans>
#+end_src
上面多了一个baseService的bean,这个bean没有指定class对象，但是多了一个abstract="true"的属性，表示这个bean是抽象的，abstract
为true的bean在spring容器中不会被创建，只是会将其当作bean定义的模板，而serviceB和serviceC的定义中多了一个属性parent，用来指定
当前bean的父bean名称。

子bean中也可以重新定义父bean中已经定义好的配置，这样子配置会覆盖父bean中的配置信息。

* lookup-method和replaced-method
** lookup-method: 方法查找
通常情况下，我们使用的bean都是单例的，如果一个bean需要依赖于另一个bean的时候，可以在当前bean中声明另外一个bean引用，然后注入依赖的bean,
此时被依赖的bean在当前bean中自始至终都是同一个实例。
*** 案例回顾
#+begin_src java
  public class ServiceA {}

  public class ServiceB {
      private ServiceA serviceA;

      public ServiceA getServiceA() {
          return serviceA;
      }
      public void setServiceA(ServiceA serviceA) {
          this.serviceA = serviceA;
      }
  }
#+end_src
bean.xml
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">

    <bean id="serviceA" class="com.demo13.normal.ServiceA" scope="prototype"/>
    <bean id="serviceB" class="com.demo13.normal.ServiceB">
      <property name="serviceA" ref="serviceA"/>
    </bean>
  </beans>
#+end_src
上面serviceA的scope是prototype，表示serviceA是多例的，每次从容器中获取serviceA都会返回一个新的对象。

而serviceB的scope没有配置，默认是单例的，通过prototype元素将service注入。

如果我们希望beanB中每次使用beanA的时候beanA都是一个新的实例，我们可以在serviceB中价格方法去获取ServiceA,这个方法中我们主动去容器中
获取serviceA，每次获取到的都是不同的serviceA实例。

那么，如何在serviceB中获取到spring容器呢？

spring中有个接口ApplicationContextAware:
#+begin_src java
  org.springframework.context.ApplicationContextAware;
  public interface ApplicationContextAware extends Aware {
    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
  }
#+end_src
上面这个接口有个方法 *setApplicationContext* ,这个接口给了自定义的bean中获取applicationContext的能力，当我们的类实现这个接口之后，spring容器
创建bean对象的时候bean实现了这个接口，那么容器会自动调用 *setApplicationContext* 方法，将容器对象applicationContext传入，此时在我们bean
对象中就可以使用容器的任何方法了。
*** 单例bean中使用多例bean:ApplicationContext接口的方式
serviceA.java
#+begin_src java
  public class serviceA{}
#+end_src
serviceB.java
#+begin_src java
  public class ServiceB implements ApplicationContextAware { //@1
      public void say() {
          ServiceA serviceA = this.getService(); //@2
          System.out.println("this:"+this+",serviceA:"+ serviceA);
      }
      public ServiceA getServiceA() {
          return this.context.getBean(ServiceA.class);//@3
      }
      private ApplicationContext context;
      @Override
      public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
          this.context = applicationContext;
      }
  }
#+end_src
上面代码，serviceB实现了ApplicationContextAware接口，然后实现了这个接口中的setApplicationContext方法，spring容器在创建ServiceB的时候会自动调用
setApplicationContext方法。

@3： 从容器中主动获取ServiceA, 这样每次获取到的ServiceA都是一个新的实例。

@2： say方法中调用getServiceA方法获取ServiceA对象，然后将其输出。

*** 单例bean中使用多例bean: lookup-method方式实现
上面这种方式实现了单例bean中使用多例bean的需求，但是用到spring中的接口 *ApplicationContextAware* ,此时对spring的
api有耦合的作用，我们一直推行高内聚低耦合，所以应该寻求更好的办法。------->lookup-method
serviceA.java
#+begin_src java
  public class ServiceA {}
#+end_src
serviceB.java
#+begin_src java
  public class ServiceB {
      public void say() {
          ServiceA serviceA = this.getServiceA();
      }

      public ServiceA getServiceA() { //@1
          return null;
      }
  }
#+end_src
上面@1，这个方法中返回了一个null对象，下面我们通过spring来创建上面2个bean对象，然后让spring对上面的getServiceA方法进行拦截，
返回指定的bean，如下：
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">

    <bean id="serviceA" class="com.demo13.lookupmethod.ServiceA" scope="prototype"/>
    <bean id="serviceB" class="com.demo13.lookupmethod.ServiceB">
      <lookup-method name="getServiceA" bean="serviceA"/>
    </bean>
  </beans>
#+end_src
重点在于 *lookup-method* 这一行的配置，当我们调用serviceB中的getServiceA方法的时候，这个方法会拦截，然后会按照
lookup-method元素中bean属性的值作为bean的名称去容器中查找对应的bean，然后作为getServiceA的返回值返回，即调用
getServiceA方法的时候，会从spring容器中查找id为serviceA的bean然后返回。

** replaced-method: 方法替换
replace-method:方法替换，比如我们要调用serviceB中的getServiceA的时候，我们可以对ServiceB这个bean中的getServiceA方法进行拦截，
把这个调用请求转发到一个替换者处理，这就是replaced-method可以实现的功能，比lookup-method更强大更灵活。
*** replaced-method的使用3个步骤
**** 定义替换者
自定义一个替换者，替换者需要实现spring中的MethodReplacer接口，接口定义如下：
#+begin_src java
  public interface MethodReplacer {
    /**
     * @param obj 被替换方法的目标对象
     * @param method 目标对象的方法
     * @param args 方法的参数
     * @return return value for the method
     */
    Object reimplement(Object obj, Method method, Object[] args) throws Throwable;
  }
#+end_src
当调用目标对象需要被替换的方法的时候，这个调用请求会被转发到上面的替换者的reimplement方法进行处理。
#+begin_src java
  // serviceB的方法替换者
  public class ServiceBMethodReplacer implements MethodReplacer,ApplicationContextAware {
      @Override
      public Object reimplement(Object obj, Method method, Object[] args) throw Throwable {
          return this.context.getBean(ServiceA.class);
      }
      private ApplicationContext context;
      @Override
      public void setApplicationContext(ApplicationContext applicationContext)
          throws BeansException {
          this.context = applicationContext;
      }
  }
#+end_src
**** 定义替换者bean
#+begin_src java
  <bean id="serviceBMethodReplacer" class="com.demo14.ServiceBMethodReplacer" />
#+end_src
**** 通过replaced-method元素配置目标bean需要被替换的方法
#+begin_src xml
  <bean id="serviceB" class="com.demo14.ServiceB">
    <replaced-method name="getServiceA" replacer="serviceAMethodReplacer"/>
  </bean>
#+end_src
+ name: 用于指定当前bean需要被替换的方法
+ replacer: 替换者，即实现了MethodReplace接口的类对应的bean
xml配置中当调用serviceB的getServiceA的时候，会自动调用serviceAMethodReplacer这个bean中的
reimplement方法进行处理。

* 代理详解（java动态代理&CGLIB代理）
** jdk动态代理详解
jdk中为实现代理提供了支持，主要用到两个类
#+begin_src java
  java.lang.reflect.Proxy;
  java.lang.reflect.InvocationHandler;
#+end_src
jdk自带的代理使用上面有个限制，只能为接口创建代理，如果需要给具体的类创建代理类，需要用cglib
*** java.lang.reflect.Proxy
这是jdk动态代理中主要的一个类，里面有一些静态方法会经常用到
**** getProxyClass方法
为指定的接口创建代理类，返回代理类的Class对象
#+begin_src java
  public static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces);
#+end_src
参数说明：
+ loader: 定义代理类的类加载器
+ interfaces: 指定需要实现的接口列表，创建的代理默认会按顺序实现interfaces指定的接口
**** newProxyInstance方法
创建代理类的实例对象
#+begin_src java
  public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
#+end_src
这个方法先为指定的接口创建代理类，然后会生成代理类的一个实例，最后一个参数比较特殊，是InvocatonHandler类型的，这个是个接口如下：
#+begin_src java
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
#+end_src
上面方法会返回一个代理对象，当调用代理对象的任何方法的时候，会被InvocationHandler接口的invoke方法处理，所以主要代码需要写在invoke方法中。
*** isProxy方法
判断指定的类是否是一个代理类
#+begin_src java
  public static boolean isProxyClass(Class<?> cl);
#+end_src
*** getInvocationHandler方法
获取代理对象的InvocationHandler对象
#+begin_src java
  public static InvocationHandler getInvocationHandler(Object proxy) throws IllegalArgumentException;
#+end_src

*** 创建代理：方式1
**** 步骤
1. 调用Proxy.getProxyClass方法获取代理类的Class对象
2. 使用InvocationHandler接口创建代理类的处理器
3. 通过代理类和InvocationHandler创建代理对象
4. 使用代理对象了
**** 案例
创建接口IService
#+begin_src java
  public interface IService {
      void m1();
      void m2();
      void m3();
  }
#+end_src
创建IService接口的代理对象
#+begin_src java
  @Test
  public void m1() throws NoSuchMethodException,IllegalAccessException,InvocationTargetException,InstantiationException {
    // 1. 获取接口对应的代理类
    Class<IService> proxyClass = (Class<IService>)Proxy.getProxyClass(IService.class.getClassLoader(), IService.class);
    // 2. 创建代理类的处理器
    InvocationHandler invocationHandler = new InvocationHandler() {
            @override
            public Object invoke(Object proxy, Method method, Ojbect[] args) throws Throwable {
              System.out.println("我是InvocationHandler,被调用的方法是" + method.getName());
              return null;
            }
        };
    // 3. 创建代理实例
    IService proxyService = proxyClass.getConstructor(InvocationHandler.class).newInstance(invocationHandler);
    // 4. 调用代理的方法
    proxyService.m1();
    proxyService.m2();
    proxyService.m3();
  }

#+end_src
*** 创建代理：方式2
**** 步骤
1. 使用InvocationHandler接口创建代理类的处理器
2. 使用proxy类的静态方法newProxyInstance直接创建代理对象
3. 使用代理对象
**** 案例
#+begin_src java
  @Test
  public void m2() throws NoSuchMethodException,IllegalAccessException,InvocationTargetException,InstantiationException {
      //1. 创建代理处理器
      InvocationHandler invocationHandler = new InvocationHandler() {
              @override
              public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println("我是InvocationHandler,被调用的方法是" + method.getName());
                return null;
              }
          };
      // 2. 创建代理实例
      IService proxyService = (IService)Proxy.newProxyInstance(IService.class.getClassLoader(), new Class[]{IService.class}, invocationHandler);
      // 3. 调用代理的方法
      proxyService.m1();
      proxyService.m2();
      proxyService.m3();
  }

#+end_src

* java注解
** 什么是注解
注解是对代码的一种增强，可以在代码编译或者程序运行期间获取注解的信息，然后根据这些信息做各种你牛逼的事情
** 注解的使用方式
*** 步骤
1. 定义注解
2. 使用注解
3. 获取注解信息做各种牛逼的事情
*** 定义注解
**** 定义注解语法
jdk中注解相关的类和接口都定义于 java.lang.annotation 包中。

注解的定义和我们常见的类，接口类似，只是注解使用 @interface 来定义，如下定义一个名称为MyAnnotation的注解
#+begin_src java
  public @interface MyAnnotation{}
#+end_src
**** 注解中定义参数
注解中有没有参数都可以，定义参数如下：
#+begin_src java
  public @interface 注解名称 {
      [public] 参数类型 参数名称1() [default 参数默认值];
      [public] 参数类型 参数名称2() [default 参数默认值];
      [public] 参数类型 参数名称3() [default 参数默认值];

  }

#+end_src
注解中可以定义多个参数，参数的定义有以下特点：
1. 访问修饰符必须为public,不屑默认为public
2. 该元素的类型只能是基本数据类型，String,Class,枚举类型，注解类型(体现了注解的嵌套效果)以及上述类型的一位数组
3. 该元素的名称一般定义为名词，如果注解中只有一个元素，请把名字起为value(后面使用会带来便利操作)
4. 参数名称后面()不是定义方法参数的地方，也不能在括号中定义任何参数，仅仅只是一个特殊的语法。
5. default代表默认值，值比u和第二点定义的类型保持一致。
6. 如果没有默认值，代表后续使用注解时必须给该类型元素赋值。
**** 指定注解的使用范围： @Target
使用@Target注解定义注解的使用范围如下：
#+begin_src java
  @Target(value={ElementType.TYPE, ElementType.METHOD})
  public @interface MyAnnotation{}
#+end_src
上面指定了MyAnnotation注解可以用在类，接口，注解类型，枚举类型以及方法上面，自定义注解上也可以不使用@Target注解，如果不使用，表示自定义
注解可以用在任何地方。

下面看一下@Target源码：
#+begin_src java
  @Documented
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.ANNOTATION_TYPE)
  public @interface Target {
    ElementType[] value();
  }
#+end_src
有一个参数时value,时ElemtnType类型的一个数组，再来看一下ElementType,是个枚举，源码如下：
#+begin_src java
  pacage java.lang.annotation;
  public enum ElementType {
    /*类，接口，枚举，注解上面*/
    TYPE,
    /*字段上*/
    FIELD,
    /*方法上*/
    Mehtod,
    /*方法参数上*/
    PARAMETER,
    /*构造函数上*/
    CONSTRUCTOR,
    /*本地变量上*/
    LOCAL_VARIABLE,
    /*注解上*/
    ANNOTATION_TYPE,
    /*包上*/
    PACKAGE,
    /*类型参数上*/
    TYPE_PARAMETER,
    /*类型名称上*/
    TYPE_USE

  }
#+end_src

**** 指定注解的保留策略：@Retention
***** java程序的三个过程
1. 源码阶段
2. 源码被编译为字节码之后变成class文件
3. 字节码被虚拟机加载然后运行
***** 自定义保留策略
#+begin_src java
@Retention(RetentionPolicy.SOURCE)
public @interface MyAnnotation{}
#+end_src
上面指定了MyAnnotation只存在于源码阶段，后面的阶段都会丢失。

@Retention源码
#+begin_src java
  @Documented
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.ANNOTATION_TYPE)
  public @interface Retention {
      RetentionPolicy value();
  }

#+end_src
有一个value参数，类型为RetentionPolicy枚举，如下：
#+begin_src java
  public enum RetentionPolicy {
    /*注解值保留在源码阶段，编译为字节码之后就丢失了，也就是class文件中就不存在了*/
    SOURCE,
    /*注解只保留在源码和字节码中，运行阶段会丢失*/
    CLASS,
    /*源码，字节码，运行期间都存在*/
    RUNTIME
  }
#+end_src

*** 使用注解
**** 语法
将注解加载使用的目标上面，如下：
#+begin_src java
  @注解名称(参数1=值1，参数2=值2，参数n=值n)
  目标对象
#+end_src
**** 无参注解
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann1{ // @1
  }

  @Ann1 //@2
  public class UseAnnotation1{}

#+end_src
@1: Ann1为无参注解

@2：类上使用@Ann1注解，没有参数

**** 一个参数注解
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann2 { //@1
      String name();
  }
  @Ann2(name = "java1") //@2
  public class UseAnnotation2 {
  }
#+end_src
**** 一个参数为value的注解，可以省略参数名称
只有一个参数，名称为value的时候，使用时参数名称可以省略
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann3 {
      String value();//@1
  }
  @Ann3("java1") //@2
  public class UseAnnotation3 {
  }
#+end_src
@1: 注解之后的一个参数，名称为value。

@2：使用注解，参数名称value省略了

**** 数组类型参数
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann4 {
      String[] name();//@1
  }

  @Ann4(name = {"java1", "java2"}) //@2
  public class UseAnnotation4 {
      @Ann4(name = "如果只有一个值，{}可以省略}") //@3
      public class T1 {
      }
  }
#+end_src
@1: name的类型是一个String类型的数组

@2：name有多个值的时候，需要用{}包含起来

@3: 如果name只有一个值，{}可以省略
**** 为参数指定默认值
通过default为参数指定默认值，用的时候如果没有设置值，则取默认值的参数，使用的时候必须为参数设置值，如下
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann5 {
      String[] name() default {"java", "spring"};//@1
      int[] score() default 1; //@2
      int age() default 30; //@3
      String address(); //@4
  }
  @Ann5(age = 32,address = "上海") //@5
  public class UseAnnotation5 {}
#+end_src
@1： 数组类型通过{}指定默认值

@2： 数组类型参数，默认值只有一个省略了{}符号

@3： 默认值为30

@4： 未指定默认值

@5： age=32对默认值进行了覆盖，并且为address指定了值

*** 综合案例
#+begin_src java
  @Target(value = {ElementType.TYPE,ElementType.METHOD,ElementType.FIELD,ElementType.PARAMETER,ElementType.CONSTRUCTOR,ElementType.LOCAL_VARIABLE})
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann6 {
      String value();
      ElementType elementType();
  }


  @Ann6(value = "用在类上", elementType = ElementType.TYPE)
  public class UseAnnotation6 {
      @Ann6(value = "用在字段上", elementType = ElementType.FIELD)
      private String a;
      @Ann6(value = "用在构造方法上", elementType = ElementType.CONSTRUCTOR)
      public UseAnnotation6(@Ann6(value = "用在方法参数上", elementType = ElementType.PARAMETER) String a) {
          this.a = a;
      }
      @Ann6(value = "用在方法上", elementType = ElementType.METHOD)
      public void m1() {
          @Ann6(value = "用在了本地变量上", elementType = ElementType.LOCAL_VARIABLE) String a;
      }
  }
#+end_src
上面演示了自定义注解在类，字段，构造器，方法参数，方法，本地变量上的使用，@Ann6注解有个elementType参数，我想通过这个参数的值告诉大家
对应@Target中的那个值来限制使用目标的，注意以下上面每个elementType的值。

*** @Target(ElementType.TYPE_PARAMETER)
这个是1.8之后才有的，用来标注类型参数，类型参数一般在类后面声明或者方法上面声明，这块需要先了解以下泛型

案例：
#+begin_src java
  @Target(value = {ElementType.TYPE_PARAMETER})
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann7 {
      String value();
  }

  public class UseAnnotation7<@Ann7("T0是在类上声明的一个泛型类型变量") T0, @Ann7("T1是在类上声明的一个泛型类型变量") T1> {
      public <@Ann7("T2是在方法上声明的泛型类型变量") T2> void m1() {
      }
      public static void main(String[] args) throws NoSuchMethodException {
          for (TypeVariable typeVariable : UseAnnotation7.class.getTypeParameters()) {
              print(typeVariable);
          }
          for (TypeVariable typeVariable : UseAnnotation7.class.getDeclaredMethod("m1").getTypeParameters()) {
              print(typeVariable);
          }
      }
      private static void print(TypeVariable typeVariable) {
          System.out.println("类型变量名称:" + typeVariable.getName());
          Arrays.stream(typeVariable.getAnnotations()).forEach(System.out::println);
      }
  }
#+end_src
类和方法上面可以声明泛型类型的变量，下面是运行结果
#+begin_src java
  类型变量名称:T0
  @com.javacode2018.lesson001.demo18.Ann7(value=T0是在类上声明的一个泛型类型变量)
  类型变量名称:T1
  @com.javacode2018.lesson001.demo18.Ann7(value=T1是在类上声明的一个泛型类型变量)
  类型变量名称:T2
  @com.javacode2018.lesson001.demo18.Ann7(value=T2是在方法上声明的泛型类型变量)
#+end_src

*** @Target(ElementType.TYPE_USE)
这个是1.8加上的，能用在任何类型名称上面
#+begin_src java
  @Target({ElementType.TYPE_USE})
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann10 {
      String value();
  }
  @Ann10("用在了类上")
  public class UserAnnotation10<@Ann10("用在了类变量类型V1上") V1, @Ann10("用在了类变量类型V2上") V2> {
      private Map<@Ann10("用在了泛型类型上") String, Integer> map;
      public <@Ann10("用在了参数上") T> String m1(String name) {
          return null;
      }
  }
#+end_src
类后面的V1、V2都是类型名称，Map后面的尖括号也是类型名称，m1方法前面也定义了一个类型变量，名称为T

** 注解信息的获取
为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect反射包下新增了AnnotatedElement接口，他主要用于表示目前正在虚拟机中
运行的程序中已使用注解的元素，通过该接口提供的方法，可以利用反射技术读取注解的信息,UML图如下(实现类)
*** AnnotateElement
+ Method： 用来表示方法信息
+ TypeVariable: 用来表示类型变量信息，如：类上定义的泛型类型变量，方法上面定义的泛型类型变量
+ Class: 用来表示类的信息
+ Package: 用来表示包的信息
+ Field: 用来表示类中属性信息
+ Constructor: 用来表示构造方法信息
+ Parameter: 用来表示方法参数信息
*** AnnotateElement常用方法
| 返回值                 | 方法名称                                                         | 说明                                                                                                                                                      |
|------------------------+------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| <A extends Annotation> | getAnnotation(Class<A> annotationClass)                          | 该元素如果存在指定类型的注解，则返回这些注解，否则返回 null。                                                                                             |
| Annotation[]           | getAnnotations()                                                 | 返回此元素上存在的所有注解，包括从父类继承的                                                                                                              |
| boolean                | isAnnotationPresent(Class<? extends Annotation> annotationClass) | 如果指定类型的注解存在于此元素上，则返回true，否则返回 false。                                                                                            |
| Annotation[]           | getDeclaredAnnotations()                                         | 返回直接存在于此元素上的所有注解，注意，不包括父类的注解，调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响，没有则返回长度为0的数组 |
*** 案例
要解析的类如下
#+begin_src java
  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;
  import java.util.Map;
  @Target({ElementType.PACKAGE,
              ElementType.TYPE,
              ElementType.FIELD,
              ElementType.CONSTRUCTOR,
              ElementType.METHOD,
              ElementType.PARAMETER,
              ElementType.TYPE_PARAMETER,
              ElementType.TYPE_USE})
              @Retention(RetentionPolicy.RUNTIME)
              @interface Ann11 {
                  String value();
              }

  @Target({ElementType.PACKAGE,
              ElementType.TYPE,
              ElementType.FIELD,
              ElementType.CONSTRUCTOR,
              ElementType.METHOD,
              ElementType.PARAMETER,
              ElementType.TYPE_PARAMETER,
              ElementType.TYPE_USE})
              @Retention(RetentionPolicy.RUNTIME)
              @interface Ann11_0 {
                  int value();
              }

  @Ann11("用在了类上")
  @Ann11_0(0)
  public class UseAnnotation11<@Ann11("用在了类变量类型V1上") @Ann11_0(1) V1,@Ann11("用在了类变量类型V2上") @Ann11_0(2) V2> {
      @Ann11("用在了字段上")
      @Ann11_0(3)
      private String name;

      private Map<@Ann11("用在了泛型类型上,String") @Ann11_0(4) String, @Ann11("用在了泛型类型上,Integer") @Ann11_0(5) Integer> map;

      @Ann11("用在了构造方法上")
      @Ann11_0(6)
      public UseAnnotation11() {
          this.name = name;
      }

      @Ann11("用在了返回值上")
      @Ann11_0(7)
      public String m1(@Ann11("用在了参数上") @Ann11_0(8) String name) {
          return null;
      }
  }
#+end_src
**** 解析类上的注解
***** 解析这部分
#+begin_src java
  @Ann11("用在了类上")
#+end_src
***** 代码
#+begin_src java
  @Test
  public void m1() {
      for (Annotation annotation : UserAnnotation11.class.getAnnotations()) {
          System.out.println(annotation);
      }
  }
#+end_src
运行输出
#+begin_src java
  @com.demo18.Ann11(value=用在了类上)
  @com.demo18.Ann11_0(value=0)
#+end_src
**** 解析类上的类型变量
解析类名后面的尖括号的部分，即下面这部分
#+begin_src java
  UseAnnotation11<@Ann11("用在了类变量类型V1上") @Ann11_0(1) V1, @Ann11("用在了类变量类型V2上") @Ann11_0(2) V2>
#+end_src
用例代码：
#+begin_src java
  @Test
  public void m2() {
      TypeVariable<Class<UserAnnotation10>>[] typeParameters = UserAnnotation10.class.getTypeParameters();
      for (TypeVariable<Class<UserAnnotation10>> typeParameter : typeParameters) {
          System.out.println(typeParameter.getName() + "变量类型注解信息：");
          Annotation[] annotations = typeParameter.getAnnotations();
          for (Annotation annotation : annotations) {
              System.out.println(annotation);
          }
      }
  }
#+end_src
运行输出：
#+begin_src java
  V1变量类型注解信息：
  @com.demo18.Ann11(value=用在了类变量类型V1上)
  @com.demo18.Ann11_0(value=1)
  V2变量类型注解信息：
  @com.demo18.Ann11(value=用在了类变量类型V2上)
  @com.demo18.Ann11_0(value=2)
#+end_src
**** 解析字段name上的注解
用例代码：
#+begin_src java
  @Test
  public void m3() throws NoSuchFieldException {
      Field nameField = UserAnnotation11.class.getDeclaredField("name");
      for (Annotation annotation : nameField.getAnnotations()) {
          System.out.println(annotation);
      }
  }
#+end_src
运行输出
#+begin_src java
  @com.javacode2018.lesson001.demo18.Ann11(value=用在了字段上)
  @com.javacode2018.lesson001.demo18.Ann11_0(value=3)
#+end_src
**** 解析泛型字段map上的注解
用例代码：
#+begin_src java
  @Test
  public void m4() throws NoSuchFieldException, ClassNotFoundException {
      Field field = UseAnnotation11.class.getDeclaredField("map");
      Type genericType = field.getGenericType();
      Type[] actualTypeArguments = ((ParameterizedType)genericType).getActualTypeArguments();
      AnnotatedType annotatedType = field.getAnnotatedType();
      AnnotatedType[] annotatedActualTypeArguments = ((AnnotatedParameterizedType)annotatedType).getAnnotatedActualTypeArguments();
      int i = 0;
      for (AnnotatedType actualTypeArgument : annotatedActualTypeArguments) {
          Type actualTypeArgument1 = actualTypeArguments[i++];
          System.out.println(actualTypeArgument1.getTypeName() + "类型上的注解如下：");
          for (Annotation annotation : actualTypeArgument.getAnnotations()) {
              System.out.println(annotation);
          }
      }
  }
#+end_src
输出如下：
#+begin_src java
  java.lang.String类型上的注解如下：
  @com.javacode2018.lesson001.demo18.Ann11(value=用在了泛型类型上,String)
  @com.javacode2018.lesson001.demo18.Ann11_0(value=4)
  java.lang.Integer类型上的注解如下：
  @com.javacode2018.lesson001.demo18.Ann11(value=用在了泛型类型上,Integer)
  @com.javacode2018.lesson001.demo18.Ann11_0(value=5)
#+end_src

**** 解析构造函数上的注解
用例代码：
#+begin_src java
  @Test
  public void m5() {
      Constructor<?> constructor = UseAnnotation11.class.getConstructors()[0];
      for (Annotation annotation : constructor.getAnnotations()) {
          System.out.println(annotation);
      }
  }
#+end_src
运行输出：
#+begin_src java
  @com.javacode2018.lesson001.demo18.Ann11(value=用在了构造方法上)
  @com.javacode2018.lesson001.demo18.Ann11_0(value=6)
#+end_src



**** 解析m1方法上的注解
用例代码：
#+begin_src java
  @Test
  public void m6() throws NoSuchMethodException {
      Method method = UseAnnotation11.class.getMethod("m1", String.class);
      for (Annotation annotation : method.getAnnotations()) {
          System.out.println(annotation);
      }
  }
#+end_src
输出：
#+begin_src java
  @com.javacode2018.lesson001.demo18.Ann11(value=用在了返回值上)
  @com.javacode2018.lesson001.demo18.Ann11_0(value=7)
#+end_src


**** 解析m1方法参数注解
用例代码：
#+begin_src java
  @Test
  public void m7() throws NoSuchMethodException {
      Method method = UseAnnotation11.class.getMethod("m1", String.class);
      for (Parameter parameter : method.getParameters()) {
          System.out.println(String.format("参数%s上的注解如下:",parameter.getName()));
          for (Annotation annotation : parameter.getAnnotations()) {
              System.out.println(annotation);
          }
      }
  }
#+end_src
运行输出：
#+begin_src java
  参数arg0上的注解如下:
  @com.javacode2018.lesson001.demo18.Ann11(value=用在了参数上)
  @com.javacode2018.lesson001.demo18.Ann11_0(value=8)
#+end_src

** @Inherit: 实现类之间的注解继承
*** 用法
首先看一下源码
#+begin_src java
  @Documented
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.ANNOTATION_TYPE)
  public @interface Inherited {
  }
#+end_src
我们通过@Target元注解的属性可以看出，这个@Inherit是专门用来修饰注解的。
**** 作用
让子类可以继承父类中被 *@Inherit* 修饰的注解，注意是继承父类中的，如果接口中的注解也使用 *@Inherit* 修饰了，那么接口的实现类是无法继承这个注解的。
*** 案例
#+begin_src java
  import java.lang.annotation.*;
  public class InheritAnnotationTest {
      @Target(ElementType.TYPE)
      @Retention(RetentionPolicy.RUNTIME)
      @Inherited
      @interface A1{ //@1
      }
      @Target(ElementType.TYPE)
      @Retention(RetentionPolicy.RUNTIME)
      @Inherited
      @interface A2{ //@2
      }
      @A1 //@3
      interface I1{}
      @A2 //@4
      static class C1{}
      static class C2 extends C1 implements I1{} //@5
      public static void main(String[] args) {
          for (Annotation annotation : C2.class.getAnnotations()) { //@6
              System.out.println(annotation);
          }
      }
  }
#+end_src
@1：定义了一个注解A1，上面使用了@Inherited，表示这个具有继承功能

@2：定义了一个注解A2，上面使用了@Inherited，表示这个具有继承功能

@3：定义接口I1，上面使用了@A1注解

@4：定义了一个C1类，使用了A2注解

@5：C2继承了C1并且实现了I1接口

@6：获取C2上以及从父类继承过来的所有注解，然后输出
#+begin_src java
  @com.javacode2018.lesson001.demo18.InheritAnnotationTest$A2()
#+end_src
从输出中可以看出类可以继承父类上被@Inherit修饰的注解，而不能继承接口上被@Inherit修饰的注解，这个 *一定要要注意！！！！！！* 。

** @Repeatable重复使用注解
#+begin_src java
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.TYPE)
  @interface Ann12{}
  @Ann12
  @Ann12
  public class UseAnnotation12 {
  }
#+end_src
上面代码会报错，原因是：UseAnnotation12上面重复使用了@Ann12注解，默认情况下@Ann12注解是不允许重复使用的。

像上面这样，如果我们想重复使用注解的时候，需要用到 @Repeatable 注解
*** 使用步骤
**** 先定义容器注解
#+begin_src java
  @Retention(RetentionPolicy.RUNTIME)
  @Target({ElementType.TYPE, ElementType.FIELD})
  @interface Ann12s {
      Ann12[] value(); //@1
  }
#+end_src
容器注解中必须有个value类型的参数，参数类型为子注解类型的数组。
**** 为注解指定容器
要让一个注解可以反复使用，需要在注解上加上@Repeatable注解，@Repeatable中value的值为容器注解，如下代码中的@2
#+begin_src java
  @Retention(RetentionPolicy.RUNTIME)
  @Target({ElementType.TYPE, ElementType.FIELD})
  @Repeatable(Ann12s.class)//@2
  @interface Ann12 {
      String name();
  }
#+end_src
**** 使用注解
重复使用相同的注解有2种方式，如下面代码
1. 重复使用注解，如下面的类上重复使用@Ann12注解
2. 通过容器注解来使用更多个注解，如下面的字段v1上使用@Ann12s容器注解
#+begin_src java
  @Ann12(name = "Java")
  @Ann12(name = "Spring")
  public class UseAnnotation12 {
      @Ann12s({@Ann12(name = "Java高并发"),@Ann12(name = "mysql高手")})
      private String v1;
  }
#+end_src
**** 获取注解信息
#+begin_src java
  @Test
  public void test1() throws NoSuchFieldException {
      Annotation[] annotations = UseAnnotation12.class.getAnnotations();
      for (Annotation annotation : annotations) {
          System.out.println(annotation);
      }
      System.out.println("-------------");
      Field v1 = UseAnnotation12.class.getDeclaredField("v1");
      Annotation[] declaredAnnotations = v1.getDeclaredAnnotations();
      for (Annotation declaredAnnotation : declaredAnnotations) {
          System.out.println(declaredAnnotation);
      }
  }
#+end_src
运行输出：
#+begin_src java
  @com.javacode2018.lesson001.demo18.Ann12s(value=[@com.javacode2018.lesson001.demo18.Ann12(name=Java),@com.javacode2018.lesson001.demo18.Ann12(name=Spring系列)])
  -------------
  @com.javacode2018.lesson001.demo18.Ann12s(value=[@com.javacode2018.lesson001.demo18.Ann12(name=Java高并发系列),@com.javacode2018.lesson001.demo18.Ann12(name=mysql高手系列)])
#+end_src

** ==以上是Java中对注解的支持，下面是spring中对于注解方面的支持==
** Spring中对于注解方面的支持
*** 先瞅一个问题
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface A1 {
      String value() default "a";//@0
  }
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @A1
  @interface B1 { //@1
      String value() default "b";//@2
  }
  @B1("Java") //@3
  public class UseAnnotation13 {
      @Test
      public void test1() {
          //AnnotatedElementUtils是spring提供的一个查找注解的工具类
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation13.class, B1.class));
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation13.class, A1.class));
      }
  }
#+end_src
@0：A1注解value参数值默认为a

@1：B1注解上使用到了@A1注解

@2：B1注解value参数值默认为b

@2：UseAnnotation13上面使用了@B1注解，value参数的值为：java

test1方法中使用到了spring中的一个类 AnnotatedElementUtils ，通过这个工具类可以很方便的获取注解的各种信息，方法中的2行代码用于获取UseAnnotation13类上B1注解和A1注解的信息。

输出结果如下：
#+begin_src java
  @com.javacode2018.lesson001.demo18.B1(value=Java)
  @com.javacode2018.lesson001.demo18.A1(value=a)
#+end_src
此时有个问题：此时如果想在 UseAnnotation13 上给B1上的A1注解设置值是没有办法的，注解定义无法继承导致的，如果注解定义上面能够继承，那用起来会爽很多，spring通过@Aliasfor方法解决了这个问题。
*** Spring @AliasFor: 对注解进行增强
**** 案例1 通过 @AliasFor 解决刚才的难题
#+begin_src java
  import org.junit.Test;
  import org.springframework.core.annotation.AliasFor;
  import org.springframework.core.annotation.AnnotatedElementUtils;
  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface A14 {
      String value() default "a";//@0
  }
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @A14 //@6
  @interface B14 { //@1
      String value() default "b";//@2
      @AliasFor(annotation = A14.class, value = "value") //@5
      String a14Value();
  }
  @B14(value = "Java",a14Value = "通过B14给A14的value参数赋值") //@3
  public class UseAnnotation14 {
      @Test
      public void test1() {
          //AnnotatedElementUtils是spring提供的一个查找注解的工具类
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation14.class, B14.class));
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation14.class, A14.class));
      }
  }
#+end_src
运行输出：
#+begin_src java
  @com.javacode2018.lesson001.demo18.B14(a14Value=通过B14给A14的value参数赋值, value=Java)
  @com.javacode2018.lesson001.demo18.A14(value=通过B14给A14的value参数赋值)
#+end_src
这个相当于给某个注解指定别名，即将B1注解中 a14Value 参数作为 A14 中 value 参数的别名，当给B1的a14Value 设置值的时候，就相当于给 A14的value设置值 ，有个前提是@AliasFor注解的annotation 参数指定的注解需要加载当前注解上面，如：@6
**** 案例2 同一个注解中使用@AliasFor
#+begin_src java
  import org.junit.Test;
  import org.springframework.core.annotation.AliasFor;
  import org.springframework.core.annotation.AnnotatedElementUtils;
  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;
  @Target({ElementType.TYPE, ElementType.FIELD})
  @Retention(RetentionPolicy.RUNTIME)
  @interface A15 {
      @AliasFor("v2")//@1
      String v1() default "";
      @AliasFor("v1")//@2
      String v2() default "";
  }
  @A15(v1 = "我是v1") //@3
  public class UseAnnotation15 {
      @A15(v2 = "我是v2") //@4
      private String name;
      @Test
      public void test1() throws NoSuchFieldException {
          //AnnotatedElementUtils是spring提供的一个查找注解的工具类
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation15.class, A15.class));
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation15.class.getDeclaredField("name"), A15.class));
      }
  }
#+end_src
注意上面代码，A15注解中（@1和@2）的2个参数都设置了@AliasFor，@AliasFor如果不指定annotation 参数的值，那么 annotation 默认值就是当前注解，所以上面2个属性互为别名，当
给v1设置值的时候也相当于给v2设置值，当给v2设置值的时候也相当于给v1设置值。

运行输出：
#+begin_src java
  @com.javacode2018.lesson001.demo18.A15(v1=我是v1, v2=我是v1)
  @com.javacode2018.lesson001.demo18.A15(v1=我是v2, v2=我是v2)
#+end_src
从输出中可以看出v1和v2的值始终是相等的，上面如果同时给v1和v2设置值的时候运行代码会报错。

回头来看看@AliasFor的源码:
#+begin_src java
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.METHOD)
  @Documented
  public @interface AliasFor {
      @AliasFor("attribute")
      String value() default "";
      @AliasFor("value")
      String attribute() default "";
      Class<? extends Annotation> annotation() default Annotation.class;
  }
#+end_src
AliasFor注解中 value 和 attribute 互为别名，随便设置一个，同时会给另外一个设置相同的值。


**** 案例3 @AliasFor中不指定value和attribute
当@AliasFor中不指定value或者attribute的时候，自动将@AliasFor修饰的参数作为value和attribute的值，如下@AliasFor注解的value参数值为name
#+begin_src java
  import org.junit.Test;
  import org.springframework.core.annotation.AliasFor;
  import org.springframework.core.annotation.AnnotatedElementUtils;
  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface A16 {
      String name() default "a";//@0
  }
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @A16
  @interface B16 { //@1
      @AliasFor(annotation = A16.class) //@5
      String name() default "b";//@2
  }
  @B16(name="我是v1") //@3
  public class UseAnnotation16 {
      @Test
      public void test1() throws NoSuchFieldException {
          //AnnotatedElementUtils是spring提供的一个查找注解的工具类
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation16.class, A16.class));
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation16.class, B16.class));
      }
  }
#+end_src
运行输出：
#+begin_src java
  @com.javacode2018.lesson001.demo18.A16(name=我是v1)
  @com.javacode2018.lesson001.demo18.B16(name=我是v1)
#+end_src

* @Configration和@Bean注解
** 前言
之前我们都是通过xml的方式定义bean，里面会写很多bean元素，然后spring启动的时候，就会读取bean xml配置文件，然后解析这些配置，然后会将这些bean注册到spring容器中，供使用者使用。
jdk1.5里面有了注解的功能，spring也没闲着，觉得注解挺好用的，就将注解加了进来，让我们通过注解的方式来定义bean，用起来能达到xml中定义bean一样的效果，并且更简洁一些，这里面需要用到的
注解就有 @Configuration 注解和 @Bean 注解。
** @Configration注解
*** 用法
@Configuration这个注解可以加在类上，让这个类的功能等同于一个bean xml配置文件，如下：
#+begin_src java
  @Configuration
  public class ConfigBean {
  }
#+end_src
上面代码类似于xml
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">
  </beans>
#+end_src
通过 AnnotationConfigApplicationContext 来加载 @Configuration 修饰的类，如下：
#+begin_src java
  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConfigBean.class);
#+end_src
此时ConfigBean类中没有任何内容，相当于一个空的xml配置文件，此时我们要在ConfigBean类中注册bean，那么我们就要用到@Bean注解了。
*** 总结 @Configuration 使用步骤：
1. 在类上使用 @Configuration 注解
2. 通过 AnnotationConfigApplicationContext 容器来加 @Configuration 注解修饰的类

** @Bean注解
*** 用法
这个注解类似于bean xml配置文件中的bean元素，用来在spring容器中注册一个bean。@Bean注解用在方法上，表示通过方法来定义一个bean，默认将方法名称作为bean名称，将方法返回值作为bean对象，注册到spring容器中。
#+begin_src java
  @Bean
  public User user1() {
      return new User();
  }
#+end_src
@Bean注解还有很多属性，我们来看一下其源码：
#+begin_src java
  @Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE}) //@1
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  public @interface Bean {
      @AliasFor("name")
      String[] value() default {};
      @AliasFor("value")
      String[] name() default {};
      @Deprecated
      Autowire autowire() default Autowire.NO;
      boolean autowireCandidate() default true;
      String initMethod() default "";
      String destroyMethod() default AbstractBeanDefinition.INFER_METHOD;
  }
#+end_src
@1：说明这个注解可以用在方法和注解类型上面。

每个参数含义：
  1. value和name是一样的，设置的时候，这2个参数只能选一个，原因是@AliasFor导致的@AliasFor这个注解不清楚的可以看这个文章：详解注解
  2. value：字符串数组，第一个值作为bean的名称，其他值作为bean的别名
  3. autowire：这个参数上面标注了@Deprecated，表示已经过期了，不建议使用了
  4. autowireCandidate：是否作为其他对象注入时候的候选bean，之前的文章中专门介绍过这个属性，不清楚的可以去看看：autowire-candidate详解
  5. initMethod：bean初始化的方法，这个和生命周期有关，后面详解
  6. destroyMethod：bean销毁的方法，也是和生命周期相关的，后面详解

*** 案例
User类
#+begin_src java
  public class User {
  }
#+end_src
Bean配置类：ConfigBean
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  public class ConfigBean {
      //bean名称为方法默认值：user1
      @Bean
      public User user1() {
          return new User();
      }
      //bean名称通过value指定了：user2Bean
      @Bean("user2Bean")
      public User user2() {
          return new User();
      }
      //bean名称为：user3Bean，2个别名：[user3BeanAlias1,user3BeanAlias2]
      @Bean({"user3Bean", "user3BeanAlias1", "user3BeanAlias2"})
      public User user3() {
          return new User();
      }
  }
#+end_src
测试类
#+begin_src java
  import org.junit.Test;
  import org.springframework.context.annotation.AnnotationConfigApplicationContext;
  import java.util.Arrays;
  public class ConfigurationTest {
      @Test
      public void test1() {
          AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConfigBean.class);//@1
          for (String beanName : context.getBeanDefinitionNames()) {
              //别名
              String[] aliases = context.getAliases(beanName);
              System.out.println(String.format("bean名称:%s,别名:%s,bean对象:%s",beanName,Arrays.asList(aliases),context.getBean(beanName)));
          }
      }
  }
#+end_src
@1：通过 AnnotationConfigApplicationContext 来加载配置类 ConfigBean ，会将配置类中所有的bean注册到spring容器中

for循环中输出了bean名称、别名、bean对象

输出如下：
#+begin_src java
  bean名称:org.springframework.context.annotation.internalConfigurationAnnotationProcessor,别名:[],bean对象:org.springframework.context.annotation.ConfigurationClassPostProcessor@3bd82cf5
  bean名称:org.springframework.context.annotation.internalAutowiredAnnotationProcessor,别名:[],bean对象:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@544fa968
  bean名称:org.springframework.context.annotation.internalCommonAnnotationProcessor,别名:[],bean对象:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@247bddad
  bean名称:org.springframework.context.event.internalEventListenerProcessor,别名:[],bean对象:org.springframework.context.event.EventListenerMethodProcessor@d35dea7
  bean名称:org.springframework.context.event.internalEventListenerFactory,别名:[],bean对象:org.springframework.context.event.DefaultEventListenerFactory@7770f470
  bean名称:configBean,别名:[],bean对象:com.javacode2018.lesson001.demo20.ConfigBean$$EnhancerBySpringCGLIB$$dde45976@5e5d171f
  bean名称:user1,别名:[],bean对象:com.javacode2018.lesson001.demo20.User@24313fcc
  bean名称:user2Bean,别名:[],bean对象:com.javacode2018.lesson001.demo20.User@7d20d0b
  bean名称:user3Bean,别名:[user3BeanAlias2, user3BeanAlias1],bean对象:com.javacode2018.lesson001.demo20.User@77f1baf5
#+end_src
从输出中可以看出，有个名称为 configBean 的bean，正是ConfigBean这个类型，可以得出，被@Configuration修饰的类，也被注册到spring容器中了最后3行输出就是几个User的bean对象了。

** @Configuration加不加到底区别在哪里呢
通常情况下bean和bean之间是有依赖关系的。

被@Configuration修饰的类，spring容器中会通过cglib给这个类创建一个代理，代理会拦截所有被@Bean修饰的方法，默认情况(bean为单例)下确保这些方法只被调用一次，从而
确保这些bean是同一个bean，即单例的。

* @ComponentScan,@ComponentScans详解
** 灵魂拷问
1. @ComponetsScan注解是做什么的？
2. basePackages的方式和basePackageClasses的方式有什么区别？你建议用哪个？为什么？
3. useDefaultFilters有什么用？
4. 常见的过滤器有哪些？
5. @ComponetsScan是在哪个类中处理的
** 背景介绍
目前为止我们知道了两种注册bean的方式
1. xml中bean元素的方式
2. @Bean注解标注方法的方式

通常情况下 ，项目中大部分类都需要交给spring去管理，按照上面这两种方式，代码量还是挺大的，为了更方便bean的注册，spring提供了
批量的方式注册bean,方便大量bean批量注册，spring中的@ComponentScan就是干这个事情的。
** @ComponentScan
@ComponentScan用于批量注册bean。

这个注解会让spring去扫描某些包及其子包中所有的类，然后将满足一定条件的类作为bean注册到spring容器容器中。

具体需要扫描哪些包？以及这些包中的类满足什么条件时被注册到容器中，这些都可以通过这个注解中的参数动态配置。

*** 注解的定义
#+begin_src java
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.TYPE)
  @Documented
  @Repeatable(ComponentScans.class) //@1
  public @interface ComponentScan {
      @AliasFor("basePackages")
      String[] value() default {};
      @AliasFor("value")
      String[] basePackages() default {};
      Class<?>[] basePackageClasses() default {};
      Class<? extends BeanNameGenerator> nameGenerator() default
          BeanNameGenerator.class;
      Class<? extends ScopeMetadataResolver> scopeResolver() default
          AnnotationScopeMetadataResolver.class;
      ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;
      String resourcePattern() default "**/*.class";
      boolean useDefaultFilters() default true;
      Filter[] includeFilters() default {};
      Filter[] excludeFilters() default {};
      boolean lazyInit() default false;
  }
#+end_src
定义上可以看出此注解可以用在任何类型上面，不过我们通常将其用在类上面。

常用参数：
#+begin_src doc

value：指定需要扫描的包，如：com.javacode2018

basePackages：作用同value；value和basePackages不能同时存在设置，可二选一

basePackageClasses：指定一些类，spring容器会扫描这些类所在的包及其子包中的类

nameGenerator：自定义bean名称生成器

resourcePattern：需要扫描包中的那些资源，默认是：**/*.class，即会扫描指定包中所有的class文件

useDefaultFilters：对扫描的类是否启用默认过滤器，默认为true

includeFilters：过滤器：用来配置被扫描出来的那些类会被作为组件注册到容器中

excludeFilters：过滤器，和includeFilters作用刚好相反，用来对扫描的类进行排除的，被排除的类不会被注册到容器中

lazyInit：是否延迟初始化被注册的bean

@1：@Repeatable(ComponentScans.class)，这个注解可以同时使用多个。

#+end_src
@ComponentScan工作的过程：
1. Spring会扫描指定的包，且会递归下面子包，得到一批类的数组
2. 然后这些类会经过上面的各种过滤器，最后剩下的类会被注册到容器中

第一：需要扫描哪些包？通过 value、backPackages、basePackageClasses 这3个参数来控制

第二：过滤器有哪些？通过 useDefaultFilters、includeFilters、excludeFilters 这3个参数来控制过滤器

默认情况下，任何参数都不设置的情况下，此时，会将@ComponentScan修饰的类所在的包作为扫描包；默认情况下useDefaultFilters为true，
这个为true的时候，spring容器内部会使用默认过滤器，规则是：凡是类上有 @Repository、@Service、@Controller、@Component 这几个注解中的任何一
个的，那么这个类就会被作为bean注册到spring容器中，所以默认情况下，只需在类上加上这几个注解中的任何一个，这些类就会自动交给spring容器来管理了。

** @Component,@Repository,@Service,@Controller
这几个注解都是spring提供的。

*** @Component注解
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  @Indexed
  public @interface Component {
      String value() default "";
  }
#+end_src
从定义中可以看出，这个注解可以用在任何类型上面。通常情况下将这个注解用在类上面，标注这个类为一个组件，
默认情况下，被扫描的时候会被作为bean注册到容器中。value参数：被注册为bean的时候，用来指定bean的名称，如果不指定，
默认为类名首字母小写。如：类UserService对应的beanname为userService
*** @Repository注解
#+begin_src java
  @Target({ElementType.TYPE})
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  @Component
  public @interface Repository {
      @AliasFor(annotation = Component.class)
      String value() default "";
  }
#+end_src
Repository上面有@Component注解。value参数上面有 @AliasFor(annotation = Component.class) ，
设置value参数的时候，也相当于给 @Component 注解中的value设置值。
*** @Service和@Controller注解源码和@Respository源码类似
*** 总结
这4个注解本质上是没有任何差别，都可以用在类上面，表示这个类被spring容器扫描的时候，可以作为一个bean组件注册到spring容器中。
spring容器中对这4个注解的解析并没有进行区分，统一采用 @Component 注解的方式进行解析，所以这几个注解之间可以相互替换。
spring提供这4个注解，是为了让系统更清晰，通常情况下，系统是分层结构的，多数系统一般分为controller层、service层、dao层。
@controller通常用来标注controller层组件，@service注解标注service层的组件，@Repository标注dao层的组件，
这样可以让整个系统的结构更清晰，当看到这些注解的时候，会和清晰的知道属于哪个层，对于spring来说，
将这3个注解替换成@Component注解，对系统没有任何影响，产生的效果是一样的。

** 案例
*** 案例1：任何参数未设置
UserController.java
#+begin_src java
  import org.springframework.stereotype.Controller;
  @Controller
  public class UserController {
  }
#+end_src
UserService.java
#+begin_src java
  import org.springframework.stereotype.Service;
  @Service
  public class UserService {
  }
#+end_src
UserDao.java
#+begin_src java
  import org.springframework.stereotype.Repository;
  @Repository
  public class UserDao {
  }
#+end_src
UserModel.java
#+begin_src java
  @Component
  public class UserModel {
  }
#+end_src
上面几个类中，分别使用了4种注解

@ComponentScan修饰的类(最外层)
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  @ComponentScan
  public class ScanBean1 {
  }
#+end_src
测试用例
#+begin_src java
  import com.javacode2018.lesson001.demo22.test1.ScanBean1;
  import org.junit.Test;
  import org.springframework.context.annotation.AnnotationConfigApplicationContext;
  public class ComponentScanTest {
      @Test
      public void test1() {
          AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ScanBean1.class);
          for (String beanName : context.getBeanDefinitionNames()) {
              System.out.println(beanName + "->" + context.getBean(beanName));
          }
      }
  }
#+end_src
@1：使用AnnotationConfigApplicationContext作为ioc容器，将 ScanBean 作为参数传入。

默认会扫描 ScanBean 类所在的包中的所有类，类上有@Component、@Repository、@Service、@Controller任何一个注解的都会被注册到容器中

*** 案例2： 指定需要扫描的包
指定需要扫描哪些包，可以通过value或者basePackage来配置，二者选其一，都配置运行会报错，下面我们通过value来配置。

ScanBean2.java
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  @ComponentScan({"com.demo22.test1.controller","com.demo22.test1.service"})
  public class ScanBean2 {
  }
#+end_src
上面指定了2需要扫描的包，这两个包中有2个类。

**** 测试用例
ComponentScanTest中新增两个方法
#+begin_src java
  @Test
  public void test2() {
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ScanBean2.class);
      for (String beanName : context.getBeanDefinitionNames()) {
          System.out.println(beanName + "->" + context.getBean(beanName));
      }
  }
#+end_src
**** 运行输出
可以看出只有controller包和service包中的2个类被注册为bean了。
**** 注意
指定包名的方式扫描存在的一个隐患，若包被重名了，会导致扫描会失效，一般情况下面我们使用basePackageClasses的方式来指定需要扫描的包，这个参数
可以指定一些类型，默认会扫描这些类所在的包及其子包中所有的类，这种方式可以有效避免这种问题。
*** 案例3：basePackageClasses指定扫描范围
我们可以在需要扫描的包中定义一个标记的接口或者类，他们的唯一的作用是作为basePackageClasses的值，其他没有任何用途。

定义接口
#+begin_src java
  public interface ScanClass {
  }
#+end_src
定义两个类
#+begin_src java
  import org.springframework.stereotype.Component;
  @Component
  public class Service1 {
  }



  import org.springframework.stereotype.Component;
  @Component
  public class Service2 {
  }
#+end_src
@ComponentScan标记的类
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  @ComponentScan(basePackageClasses = ScanClass.class)
  public class ScanBean6 {
  }
#+end_src
测试用例
#+begin_src java
  @Test
  public void test6() {
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ScanBean6.class);
      for (String beanName : context.getBeanDefinitionNames()) {
          System.out.println(beanName + "->" + context.getBean(beanName));
      }
  }
#+end_src
运行输出
#+begin_src java
  service1->com.javacode2018.lesson001.demo22.test6.beans.Service1@79924b
  service2->com.javacode2018.lesson001.demo22.test6.beans.Service2@7b9a4292
#+end_src

** includeFilters的使用
*** 用法
includeFilters参数的定义：
#+begin_src java
  Filter[] includeFilters() default {};
#+end_src
是一个 Filter 类型的数组，多个Filter之间为或者关系，即满足任意一个就可以了，看一下 Filter 的代码：
#+begin_src java
  @Retention(RetentionPolicy.RUNTIME)
  @Target({})
  @interface Filter {
      FilterType type() default FilterType.ANNOTATION;
      @AliasFor("classes")
      Class<?>[] value() default {};
      @AliasFor("value")
      Class<?>[] classes() default {};
      String[] pattern() default {};  }

#+end_src
可以看出Filter也是一个注解，参数：

type：过滤器的类型，是个枚举类型，5种类型

ANNOTATION：通过注解的方式来筛选候选者，即判断候选者是否有指定的注解

ASSIGNABLE_TYPE：通过指定的类型来筛选候选者，即判断候选者是否是指定的类型

ASPECTJ：ASPECTJ表达式方式，即判断候选者是否匹配ASPECTJ表达式

REGEX：正则表达式方式，即判断候选者的完整名称是否和正则表达式匹配

CUSTOM：用户自定义过滤器来筛选候选者，对候选者的筛选交给用户自己来判断

value：和参数classes效果一样，二选一

classes：3种情况如下

当type=FilterType.ANNOTATION时，通过classes参数可以指定一些注解，用来判断被扫描的类上是否有classes参数指定的注解

当type=FilterType.ASSIGNABLE_TYPE时，通过classes参数可以指定一些类型，用来判断被扫描的类是否是classes参数指定的类型

当type=FilterType.CUSTOM时，表示这个过滤器是用户自定义的，classes参数就是用来指定用户自定义的过滤器，自定义的过滤器需要实现org.springframework.core.type.filter.TypeFilter接口

pattern：2种情况如下

当type=FilterType.ASPECTJ时，通过pattern来指定需要匹配的ASPECTJ表达式的值

当type=FilterType.REGEX时，通过pattern来自正则表达式的值

*** 案例：扫描包含注解的类
**** 需求
我们自定义一个注解，让标注有这些注解的类自动注册到容器中
**** 代码实现

定义一个注解
#+begin_src java
  import java.lang.annotation.*;
  @Documented
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface MyBean {
  }
#+end_src
创建一个类，使用这个注解标注
#+begin_src java
  @MyBean
  public class Service1 {
  }
#+end_src
再来一个类，使用spring中的 @Compontent 标注
#+begin_src java
  import org.springframework.stereotype.Component;
  @Component
  public class Service2 {
  }

#+end_src
再来一个类，使用@CompontentScan标注
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  import org.springframework.context.annotation.FilterType;
  @ComponentScan(includeFilters = {
          @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = MyBean.class)
  })
  public class ScanBean3 {
  }
#+end_src
上面指定了Filter的type为注解的类型，只要类上面有 @MyBean 注解的，都会被作为bean注册到容器中

**** 扩展：自定义注解支持定义bean名称
上面的自定义的@MyBean注解，是无法指定bean的名称的，可以对这个注解做一下改造，加个value参
数来指定bean的名称，如下：
#+begin_src java
  @Documented
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @Component //@1
  public @interface MyBean {
      @AliasFor(annotation = Component.class) //@2
      String value() default ""; //@3
  }
#+end_src
重点在于@1和@2这2个地方的代码，通过上面的参数可以间接给@Component注解中的value设
置值。这块用到了@AliasFor注解，

**** 自定义Filter案例
***** 需求
我们来个自定义的Filter，判断被扫描的类如果是 IService 接口类型的，就让其注册到容器中。
***** 代码实现
来个自定义的TypeFilter类
#+begin_src java
  import com.javacode2018.lesson001.demo22.test4.IService;
  import org.springframework.core.type.ClassMetadata;
  import org.springframework.core.type.classreading.MetadataReader;
  import org.springframework.core.type.classreading.MetadataReaderFactory;
  import org.springframework.core.type.filter.TypeFilter;
  import java.io.IOException;
  public class MyFilter implements TypeFilter {
      /**
       ,*@param metadataReader
       ,*@param metadataReaderFactory
       ,*@return
       ,*@throws IOException
       ,*/
      @Override
      public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {
          Class curClass = null;
          try {
              //当前被扫描的类
              curClass = Class.forName(metadataReader.getClassMetadata().getClassName());
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          }
          //判断curClass是否是IService类型
          boolean result = IService.class.isAssignableFrom(curClass);
          return result;
      }
  }

#+end_src
来个@ComponetScan标注的类
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  import org.springframework.context.annotation.FilterType;
  @ComponentScan(basePackages = {"com.demo22.test4"},useDefaultFilters = false, //不启用默认过滤器
                 includeFilters = {@ComponentScan.Filter(type = FilterType.CUSTOM, classes =MyFilter.class) //@1 })
  public class ScanBean5 {
  }

#+end_src
@1：type为FilterType.CUSTOM，表示Filter是用户自定义的，classes为自定义的过滤器

**** excludeFilters
配置排除的过滤器，满足这些过滤器的类不会被注册到容器中
**** @ComponentScan重复使用
从这个注解的定义上可以看出这个注解可以同时使用多个
#+begin_src java
  @ComponentScan(basePackageClasses = ScanClass.class)
  @ComponentScan(
                 useDefaultFilters = false, //不启用默认过滤器
                 includeFilters = {
                     @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes=IService.class)
                 })
  public class ScanBean7 {
  }
#+end_src
还有一种写法
#+begin_src java
  @ComponentScans({
          @ComponentScan(basePackageClasses = ScanClass.class),
          @ComponentScan(
                         useDefaultFilters = false, //不启用默认过滤器
                         includeFilters = {@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,classes = IService.class)})})
  public class ScanBean7 {
  }
#+end_src

**** spring中这一块的源码
@ComponetScan注解是被下面这个类处理的
#+begin_src java
  org.springframework.context.annotation.ConfigurationClassPostProcessor
#+end_src
这个类非常非常关键，主要用户bean的注册，前面我们介绍的@Configuration,@Bean注解也是被这个类处理的。

还有下面这些注解
#+begin_src java
  @PropertySource
  @Import
  @ImportResource
  @Compontent
#+end_src
以上这些注解都是被ConfigurationClassPostProcessor这个类处理的，内部会递归处理这些注解，完成bean的注册。

以@CompontentScan来说一下过程，第一次扫描之后会得到一批需要注册的类，然后会对这些需要注册的类进行遍历，判断是否有上面任意一个注解，如果有，会将这个类交给
ConfigurationClassPostProcessor继续处理，直到递归完成所有bean的注册。

*想成为高手，这个类是必看的。*

** 总结
1. @ComponentScan用于批量注册bean，spring会按照这个注解的配置，递归扫描指定包中的所有类，将满足条件的类批量注册到spring容器中
2. 可以通过value、basePackages、basePackageClasses 这几个参数来配置包的扫描范围
3. 可以通过useDefaultFilters、includeFilters、excludeFilters这几个参数来配置类的过滤器，被过滤器处理之后剩下的类会被注册到容器中
4. 指定包名的方式配置扫描范围存在隐患，包名被重命名之后，会导致扫描实现，所以一般我们在需要扫描的包中可以创建一个标记的接口或者类，作为basePackageClasses的值，通过这个来控制包的扫描范围
5. @CompontScan注解会被ConfigurationClassPostProcessor类递归处理，最终得到所有需要注册的类。
