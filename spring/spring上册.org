#+TITLE: Spring学习笔记（上册）
#+AUTHOR: CONGPEITONG
#+EMAIL: congpeitong2022@163.com
#+startup: overview top-level headlines only
* spring概述
** 学习spring原因
1. 最大程度简化了开发
   spring是一个非常优秀的Java框架，其目的是为了简化Java企业级的开发。
2. 大量公司使用
3. 顶级源码设计
   spring框架源码设计非常优秀，在Java开源项目中可以说是顶级的，所以想提升代码能力，强烈建议多看看spring源码，还有jdk源码。
** 什么是spring
spring是一个简化Java企业级开发的一个框架，
*** 内部技术
+ 控制反转
+ 依赖注入
+ 面向切面编程
+ spring事务管理，
*** spring集成其它框架
+ springMVC
+ springboot
+ springcloud
* 控制反转(IOC)与依赖注入(DI)
** spring中三个核心概念
+ 控制反转（IOC）
+ 依赖注入（DI）
+ 面向切面编程（AOP）
** 依赖关系
当A对象需要调用B对象的方法来实现时，说明A依赖于对象B，A和B是依赖关系。
** spring容器
spring容器的概念，容器可以放很多东西，当我们的程序启动的时候会创建spring容器，会给spring容器一个清单，清单中列出了需要创建的对象以及对象依赖关系，
spring容器会创建和组装好清单中的对象，然后将这些对象存放在spring容器中，当程序中需要使用的时候，可以到容器中查找获取，然后直接使用。
** IOC:控制反转
使用者之前需要一个对象（B）的时候都需要自己去创建和组装所依赖的对象，而现在这些创建和组装都会交给spring容器去帮助完成了，使用者只需要去spring容器中查找需要使用的对象就可以了；
这个过程中B对象的的创建和组装过程被反转了，之前是使用者自己主动去控制的，现在交给spring容器去创建和组装了，对象的构建过程被反转了，所以叫做控制反转；
IOC是面向对象编程中的一种设计原则，主要是为了降低系统代码的耦合度，让系统更加有利于去维护和扩展。
** DI:依赖注入
依赖注入是spring容器中创建对象时给其设置依赖对象的方式，比如给spring一个清单，清单中列出了需要创建B对象以及其它的一些对象（可能包含了B类型中需要依赖的对象），
此时spring在创建B对象的时候，会看到B对象需要依赖于哪些对象，然后去查找以下清单中有没有包含这些被依赖的对象，如果有就去将其创建好，然后将其传递给B对象；
可能B需要依赖于很多对象，B创建之前完全不需要知道其他对象是否存在或者其它对象在哪里以及被他们是如何创建的，而spring容器会将b依赖对象主动创建好并将其注入到B中去,
比如spring容器创建B的时候，发现B需要依赖于A，那么spring容器在清单中找到A的定义并将其创建好之后，注入到B对象中。
** 总结
1. IOC控制反转：它是一种设计理念，将对象的创建和组装的主动权交给了spring容器去做，控制的动作被反转了，降低了系统的耦合度，有利于系统维护和扩展，
   主要就是指需要使用的对象的组装的控制权被反转了，之前是自己要做的，现在交给spring容器去做了。
2. DI依赖注入，表示spring容器中创建对象时给其设置依赖对象的方式，通过某些注入的方式可以让系统更加灵活，比如自动注入等可以让系统变得很灵活。
3. spring容器：主要负责容器中对象的创建，组装，对象查找，
* spring容器基本使用及原理
** IOC容器
IOC容器是具有依赖注入功能的容器，负责 *对象的实例化*  *对象的初始化*  *对象和对象之间依赖关系配置*  *对象的销毁*  *对外提供对象的查找* 等操作，对象
的整个生命周期都是由容器来控制的。我们需要使用的对象都要都由IOC容器进行管理，不需要我们再去手动通过new的方式去创建对象，由IOC容器直接帮我们
组装好，当我们需要使用的时候直接从IOC容器中直接获取就可以了。
*** spring IOC 容器是如何知道需要管理哪些对象的
需要我们给IOC提供一个配置清单，这个配置支持 *XML格式* 和 *Java注解* 的方式。在配置文件中列出需要让IOC容器管理的对象，以及可以指定IOC容器如何构建
这些对象的，当spring容器启动的时候，就会去加载这个配置文件，然后将这些对象给组装好以供外部访问者使用。

这里所说的IOC容器也叫做spring容器。

** Bean概念
由spring容器管理的对象统称为Bean对象，Bean就是普通的Java对象，和我们自己new的对象其实是一样的，只是这些对象是由spring去创建和管理的，我们需要在
配置文件中告诉spring容器需要创建哪些bean对象，所以需要先在配置文件中定义好需要创建的bean对象，这些配置统称为bean定义配置元数据信息，spring容器
通过读取这些bean配置元数据信息来构建和组装我们需要的对象。
** spring容器使用步骤
1. 引入spring相关的maven依赖
2. 创建bean配置文件，比如 bean.xml 配置文件
3. 在bean xml文件中定义好需要spring容器管理的bean对象
4. 创建spring容器，并给spring容器指定需要装载的bean配置文件，当spring容器启动之后，会加载这些配置文件，然后创建好配置文件中定义好的bean对象，
   将这些对象放在容器中以供使用
5. 通过容器提供的方法获取容器中的对象，然后使用
** spring容器对象
spring 内部提供了很多spring容器的接口和对象，看几个比较常见的几个容器接口和具体的实现类
*** BeanFactory接口
#+begin_src java
org.springframwork.beans.factory.BeanFactory
#+end_src
spring容器中具有代表性的容器就是BeanFactory接口，这个是spring容器的顶层接口，提供了容器最基本的功能
**** 常用的几个方法
#+begin_src java
  // 按bean的id或者别名查找容器中的bean
  Object getBean(String name) throws BeansException;
  // 这是一个泛型方法，按照bean的id或者别名查找指定类型的bean，返回指定类型的bean对象
  <T> T getBean(String name, Class<T> requiredType) throws BeansException;
  // 返回容器中指定类型的bean对象
  <T> T getBean(Class<T> requiredType) throws BeansException;
  // 获取指定类型bean对象的获取器，这个方法比较特别以后专门来讲
  <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);
#+end_src
*** ApplicationContext接口
#+begin_src java
org.springframwork.context.ApplicationContext
#+end_src
这个接口继承了BeanFactory接口，所以内部包含了BeanFactory所有的功能，并且在其上进行了扩展，增加了很多企业级的功能
+ AOP
+ 国际化
+ 事件支持
+ 。。。。。
*** ClassPathXmlApplicationContext类
#+begin_src java
org.springframwor.context.support.Classpathxmlapplicationcontext
#+end_src
这个类实现了ApplicationContext接口，注意一下这个类名称包含了ClassPath XML,说明了这个容器类可以从ClassPath中加载bean xml配置文件，
然后创建xml中配置的bean对象
*** AnnotationConfigApplicationContext类
#+begin_src java
org.springframwor.context.annotation.AnnotationConfigApplicationContext
#+end_src
这个类也实现了ApplicationContext接口，注意类名包含了Annotation和config这两个单词，上面我们说过，bean的定义支持xml方式和注解方式，
当我们使用注解的方式定义bean的时候，就需要用这个容器来装载了，这个容器内部会解析注解来构建和管理需要的bean。

注解的方式相对xml方便一些，也是我们比较推荐的方式，后面我们会大量使用这种方式，具体会详解。
* xml中bean定义详解
** bean概念
被spring管理的对象统称为bean，我们程序中需要用到很多对象，我们将这些对象让spring去帮我们创建和管理，我们可以通过bean xml配置文件
告诉spring容器需要管理哪些bean,spring帮我们创建和组装好这些bean对象，spring内部将这些名称和具体的bean对象进行绑定，
然后spring容器可以通过这个的名称找对我们需要的对象，这个名称叫做bean名称，
在一个spring容器中需要是唯一的。
** bean xml配置文件格式
bean xml文件用于定义spring容器需要管理的bean，常见的格式如下：
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
          http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">

          <import resource="引入其他bean xml配置文件" />
          <bean id="bean标识" class="完整类型名称"/>
          <alias name="bean标识" alias="别名" />
  </beans>
#+end_src
beans是根元素，下面可以包含任意数量的import，bean，alias元素，下面我们对每个元素进行详解。
** bean元素详解
*** 作用
用来定义一个bean对象
*** 格式
#+begin_src xml
<bean id="bean唯一标识" name="bean名称" class="完整类型名称" factory-bean="工厂bean名称" factory-method="工厂方法"/>
#+end_src
** 名称和别名详解
*** 名称
每个bean都有一个名称，叫做bean名称，bean名称在一个spring容器中必须是唯一的，否则会报错，通过bean名称可以从spring容器中获取对应的bean对象。
*** 别名
**** 什么是别名
相当于人的外号一样，一个人可能有很多外号，当别人喊这个人的名称和外号的时候，都可以找到这个人。那么bean也是一样，也可以给bean起几个外号，
这个外号在bean中叫做bean的别名，spring容器允许使用者通过名称或者别名获取到对应的bean对象。
**** 别名定义规则
名称和别名可以通过bean元素中的id和name来定义，规则如下
1. 当id存在的时候，不管name有没有，取id为bean的名称。
2. 当id不存在的时候，此时需要看name，name的值可以通过 , ; 空格来分隔，最后会按照分隔符得到一个spring数组，数组的第一个元素作为bean的名称，
   其它的作为bean的别名。
3. 当id和name都存在的时候，id未bean名称，name用来定义多个别名
4. 当id和name都不指定的时候,bean名称自动生成，生成规则下面详细说明。
**** bean名称和别名的各种写法
#+begin_src xml
<!-- 通过id定义bean名称:user1 -->
<bean id="user1" class="com.example.UserModel/>

<!-- 通过name定义bean名称：user2 -->
<bean name="user2" class="com.example.UserModel"/>

<!-- id为名称，name为别名；bean名称：user3,1个别名：user3_1 -->
<bean name="user3" name="user3_1" class="com.example.UserModel"/>

<!-- id为名称：user4, 多个别名：user4_1,user4_2,user4_3,user4_4 -->
<bean id="user4" name="user4_1,user4_2;user4_3 user4_4" class="com.example.UserModel"/>

<!-- bean名称：user5, 别名：user5_1,user5_2,user5_3,user5_4 -->
<bean name="user5,user5_1,user5_2,user5_3,user5_4" class="com.example.UserModel"/>
#+end_src
java输出结果
#+begin_src java
public class Example {
  public static void main(String[] args) {
    //1.bean配置文件位置
    String beanXml = "classpath:/com/example/beans.xml";
    //2.创建ClassPathXmlApplicationContext容器，给容器指定需要加载的bean配置文件
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(beanXml);
    for (String beanName : Arrays.asList("user1", "user2", "user3", "user4","user5")) {
      //获取bean的别名
      String[] aliases = context.getAliases(beanName);
      System.out.println(String.format("beanName:%s,别名:[%s]", beanName,String.join(",", aliases)));
    }
    System.out.println("spring容器中所有bean如下：");
    //getBeanDefinitionNames用于获取容器中所有bean的名称
    for (String beanName : context.getBeanDefinitionNames()) {
      //获取bean的别名
      String[] aliases = context.getAliases(beanName);
      System.out.println(String.format("beanName:%s,别名:[%s]", beanName,String.join(",", aliases)));
    }
  }
}
#+end_src
***** id和name都未指定
当id和name都未指定的时候，bean名称和别名由spring自动生成。
****** bean名称为
bean的class的完整类名#编号

编号是从0开始的同种类型的没有定义名称的依次递增。
****** 别名为完整的类名
***** alias元素
alias元素也剋用来给某个bean定义别名，语法为：
#+begin_src xml
<alias name="需要定义别名的bean" alias="别名"/>
<!-- 例如 -->
<bean id="user6" class="com.javacode2018.lesson001.demo2.UserModel" />
<alias name="user6" alias="user6_1" />
<alias name="user6" alias="user6_2" />
#+end_src
** 通过import元素引入外部配置
当我们的系统比较大的时候，会分成很多模块，每个模块会对应一个bean xml文件，我们可以在一个总的bean xml中对其它bean xml进行汇总，相当于把多个bean xmln
内容合并到了一个里面，可以通过import元素引入其它bean配置文件。

语法：
#+begin_src xml
  <import resource="其它配置文件的位置"/>
  <!-- 例如 -->
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">

    <import resource="user.xml" />
    <import resource="order.xml" />

  </beans>
#+end_src

*

* 容器创建bean实例有多少种
** 通过反射调用构造方法创建bean对象
调用类的构造方法获取对应的bean实例，是使用最多的方式，这种方式只需要在xml bean元素中指定class属性,spring容器内部自动会自动调用该类型的构造方法来创建bean对象，将其放在容器中以供使用。
*** 语法
#+begin_src xml
  <bean id="bean名称" name="bean名称或别名" class="bean的完整类型名称">
    <constructor-arg index="0" value="bean的值" ref="引用的bean名称" />
    <constructor-arg index="1" value="bean的值" ref="引用的bean名称" />
    <constructor-arg index="2" value="bean的值" ref="引用的bean名称" />
    <constructor-arg index="3" value="bean的值" ref="引用的bean名称" />
    ......
    <constructor-arg index="4" value="bean的值" ref="引用的bean名称" />
  </bean>
#+end_src
+ constructor-arg: 用于指定构造方法参数的值
+ index: 构造方法中参数的位置，从0开始，依次递增
+ value: 指定参数的值
+ ref: 当插入的值为容器内其它bean的时候，这个值为容器中对应的bean的名称
** 通过静态工厂方法创建bean对象
我们可以通过创建静态工厂，内部提供一些静态方法来生成所需的对象，将这些静态方法创建的对象交给spring以供使用.
*** 语法
#+begin_src xml
  <bean id="bean名称" name="" class="静态工厂完整类名" factory-method="静态工厂方法">
    <constructor-arg index="0" value="bean的值" ref="引用的bean名称" />
    <constructor-arg index="1" value="bean的值" ref="引用的bean名称" />
    <constructor-arg index="2" value="bean的值" ref="引用的bean名称" />
    <constructor-arg index="3" value="bean的值" ref="引用的bean名称" />
  </bean>
#+end_src
+ class: 指定静态工厂完整的类名
+ factory-method: 静态工厂中的静态方法，返回需要的对象
+ constructor-arg: 用于指定静态方法参数的值，用法和上面介绍的构造方法一样
spring容器会自动调用静态工厂的静态方法获取指定的对象，将其放在容器中以供使用
** 通过实例工厂方法创建bean对象
让spring容器去调用某些对象的某些实例方法来生成bean对象放在容器中以供使用。
*** 语法
#+begin_src xml
  <bean id="bean名称" factory-bean="需要调用的实例对象bean名称" factory-method="bean对象中的方法">
    <constructor-arg index="0" value="bean的值" ref="引用的bean名称"></constructor-arg>
    <constructor-arg index="1" value="bean的值" ref="引用的bean名称"></constructor-arg>
    <constructor-arg index="2" value="bean的值" ref="引用的bean名称"></constructor-arg>
    <constructor-arg index="3" value="bean的值" ref="引用的bean名称"></constructor-arg>
    <constructor-arg index="4" value="bean的值" ref="引用的bean名称"></constructor-arg>
  </bean>
#+end_src
spring容器以 *factory-bean 的值为bean名称查找对应的bean对象，然后调用该对象中 *factory-method* 属性值指定的方法，将这个方法返回的对象作为当前的bean对象放在容器中以供使用。
** 通过FactoryBean创建bean对象
前面说到了BeanFactor接口，BeanFactory是spring容器的顶层接口，而这里要说的是FactoryBean，也是一个接口，这两个接口很容器混淆，FactoryBean可以容器spring容器通过这个接口
的实现来创建我们需要的bean对象。

FactoryBean接口源码：
#+begin_src java
  public interface FactoryBean<T> {
    /**
     * 返回创建好的对象
    */
    @Nullable
    T getObject() throws Exception;
    /**
    * 返回需要创建的对象的类型
    */
    @Nullable
    Class<?> getObjectType();
    /**
    * bean是否是单例的
    */
    default boolean isSingleton() {
      return true;
    }
  }
#+end_src
接口中有三个方法，前面两个方法需要我们去实现，getObject方法内部由开发者自己去实现对象的创建，然后将创建好的对象返回给spring容器，
getObjectType需要指定我们创建的bean类型；最后一个方法isSingleton表示通过这个接口创建的对象是否是单例的，如果返回false,那么每次
从容器中获取对象的时候都会调用这个接口的getObject()去生成bean对象。
*** 语法
#+begin_src xml
  <bean id="bean名称" class="FactoryBean接口实现类" />
#+end_src
*** 案例
#+begin_src java
  public class UserFactoryBean implements FactoryBean<UserModel> {

    int count = 1;

    @Nullable
    @Override
    public UserModel getObject() throws Exception { // @1
      UserModel userModel = new UserModel();
      userModel.setName("我是通过FactoryBean创建的第" + count + "对象"); // @4
      return userModel;
    }

    @Nullable
    @Override
    public Class<?> getObjectType() {
      return UserModel.class; //@2
    }

    @Override
    public boolean isSingleton() {
      return true; //@3
    }
  }
#+end_src
+ @1: 返回了一个创建好的usermodel对象
+ @2： 返回对象的Class对象
+ @3： 返回true，表示创建的对象是单例的，那么我们每次从容器中获取这个对象的时候都是同一个对象
+ @4： 此处用到了一个count,通过这个可以看出isSingleton不同返回值的时候从容器获取bean是否是同一个。
**** bean xml配置
#+begin_src xml
  <!-- 通过FactoryBean 创建UserModel对象 -->
  <bean id="createByFactoryBean" class="com.example.UserFactoryBean"/>
#+end_src

* bean作用域scope详解
应用中，有时候我们需要一个对象在整个应用中只有一个，有些对象希望每次使用的时候都重新创建一个，spring对我们这种需求也提供了支持，在spring中这个叫做bean的作用域，
xml中定义bean的时候，可以通过scope属性指定bean的作用域；
#+begin_src xml
  <bean id="" class="" scope="作用域" />
#+end_src
** singleton
当scope的值设置为singleton的时候，整个spring容器只会存在一个bean实例，通过容器多次查找bean的时候(调用BeanFactory的getBean方法或者bean之间注入依赖的bean对象的时候)，
返回的都是同一个bean对象，singleton是scope的默认值，所以spring容器中默认创建的bean对象是单例的，通常spring容器在启动的时候，会将scope为singleton的bean创建好放在容器中
(有个特殊的情况，当bean的lazy为true的时候，表示懒加载，那么使用的时候才会创建),用的时候直接返回。
*** 案例
**** bean xml配置
#+begin_src xml
  <!-- 单例bean，scope设置为singleton -->
  <bean id="singletonBean" class="com.demo4.BeanScopeModel" scope="singleton">
    <constructor-arg index="0" value="singleton"/>
  </bean>
#+end_src
**** BeanScopeModel代码
#+begin_src java
  public class BeanScopeModel {
      public BeanScopeModel(String beanScope) {
          System.out.println(String.format("create BeanScopeModel,{sope=%s},{this=%s}", beanScope, this));
      }
  }
#+end_src
上面构造方法中输出了一段文字，是从容器中获取bean的时候创建的还是容器启动的时候创建的。（启动时）
*** 单例bean使用注意
单例bean是整个应用共享的，所以需要考虑到线程安全的问题，之前在玩springMVC的时候，springMVC中的controller默认是单例的，有些开发者在controller中创建了一些变量，那么这些变量实际上就变成共享的了，
controller可能会被很多线程同时访问，这些线程并发去修改controller中的共享变量，可能会出现数据错乱的问题，所以使用的时候需要特别注意。

** prototype
如果scope被设置成prototype类型了，表示这个bean是多例的，通过容器每次获取的bean都是不同的实例，每次获取都会重新创建一个bean实例对象。
*** 案例
**** bean xml配置
#+begin_src xml
  <!-- 多例bean，scope被设置为prototype -->
  <bean id="prototypeBean" class="com.demo4.BeanScopeModel" scope="prototype">
    <constructor-arg index="0" value="prototype"/>
  </bean>
#+end_src
*** 多例bean使用注意
多例bean每次获取的时候都会重新创建,如果这个bean比较复杂，创建时间比较长，会影响系统的性能，这个地方需要注意
** spring web容器环境独有的三个作用域
*** request
当一个bean的作用域为request时，表示再一次http请求中，一个bean对应一个实例；对每个http请求都会创建一个bean实例,request结束的时候，
这个bean也就结束了，request作用域用在spring容器的web环境中，这个以后讲springMVC的时候就会说,spring中有个web容器接口webapplicationcontext，
这个里面对request作用域提供了支持,配置方式如下：
#+begin_src xml
  <bean id="" class="" scope="request" />
#+end_src
*** session
这个和request类似，也是用在web环境中，session级别共享的bean,每个会话对应一个bean实例，不同的session对应不同的bean实例，springMVC中会提到
#+begin_src xml
<bean id="" class="" scope="session" />
#+end_src
*** application
全局web应用级别的作用域，也是web环境中使用，一个web应用程序对应一个bean实例，通常情况下和singleton效果类似，不过也有不一样的地方，singleton
是每个spring容器中只有一个bean实例，一般我们的程序只有一个spring容器，但是，一个应用程序中可以创建多个spring容器，不同的容器中可以存在同名的bean，
但是scope=application的时候，不管应用中有多少个spring容器，这个应用中同名的bean只有一个。
** 自定义作用域的实现（自定义scope）
*** 实现scope接口
#+begin_src java
public interface Scope {
  /**
  * 返回当前作用域中name对应的bean对象
  * name：需要检索的bean的名称
  * objectFactory：如果name对应的bean在当前作用域中没有找到，那么可以调用这个ObjectFactory来创建这个对象
  **/
  Object get(String name, ObjectFactory<?> objectFactory);
  /**
  * 将name对应的bean从当前作用域中移除
  **/
  @Nullable
  Object remove(String name);
  /**
  * 用于注册销毁回调，如果想要销毁相应的对象,则由Spring容器注册相应的销毁回调，而由自定义作用域选择是不是要销毁相应的对象
  */
  void registerDestructionCallback(String name, Runnable callback);
  /**
  * 用于解析相应的上下文数据，比如request作用域将返回request中的属性。
  */
  @Nullable
  Object resolveContextualObject(String key);
  /**
  * 作用域的会话标识，比如session作用域将是sessionId
  */
  @Nullable
  String getConversationId();
}
```
*** 将自定义的scope注册到容器
需要调用 *org.springframework.beans.factory.ConfigurableBeanFactory#registerScope* 的方法，看一下这个方法的声明。
#+begin_src java
/**
*向容器中注册自定义的scope
*scopeName: 作用域名称
*scope:作用域对象
**/
void registerScope(String scopeName, Scope scope);
#+end_src
*** 使用自定义的作用域
定义bean的时候，指定bean的scope属性为自定义的作用域名称。
*** 实现
实现一个线程级别的bean作用域，同一个线程中同名的bean是同一个实例，不同的线程中的bean是不同的实例，
**** 需求中要求bean在线程中是贡献的，所以我们可以通过ThreadLocal来实现，ThreadLocal可以实现线程中数据的共享。
**** 代码ThreadScope.java
#+begin_src java
  public class ThreadScope implements Scope {
      public static final String THREAD_SCOPE = "thread"; //@1
      private ThreadLocal<Map<String,Ojbect>> beanMap = new ThreadLocal() {
              @override
              protected Object initiaValue() {
                  return new HashMap<>();
              }
          };
      @Override
      public Object get(String name, ObjectFactory<?> objectFactory) {
          Object bean = beanMap.get().get(name);
          if (Objects.isNull(bean)) {
              bean = objectFactory.getObject();
              beanMap.get().put(name, bean);
          }
          return bean;
      }
      @Nullable
      @Override
      public Object remove(String name) {
          return this.beanMap.get().remove(name);
      }
      @Override
      public void registerDestructionCallback(String name, Runnable callback) {
          //bean作用域范围结束的时候调用的方法，用于bean清理
          System.out.println(name);
      }
      @Nullable
      @Override
      public Object resolveContextualObject(String key) {
          return null;
      }
      @Nullable
      @Override
      public String getConversationId() {
          return Thread.currentThread().getName();
      }
  }
#+end_src
@1: 定义了作用域的名称为一个常量thread，可以在定义bean的时候给scope使用。
**** BeanScopeModel.java
#+begin_src java
  public class BeanScopeModel {
      public BeanScopeModel(String beanScope) {
          System.out.println(String.format("线程:%s,create BeanScopeModel,{sope=%s},{this=%s}", Thread.currentThread(), beanScope, this));
      }
  }
#+end_src
上面的构造方法中会输出当前线程的信息，到时候可以看到创建bean的线程。
**** 配置文件 beans-thread.xml
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">
    <!-- 自定义的bean -->
    <bean id="threadBean" class="com.javacode2018.lesson001.demo4.BeanScopeModel" scope="thread">
      <constructor-arg index="0" value="thread"/>
    </bean>
  </beans>
#+end_src
注意上面的scope是我们自定义的，值为thread
**** 测试用例
#+begin_src java
  public class ThradScopeTest{
      public static void main(String[] args) throws InterruptedException {
          // 配置文件位置
          String beanXml = "classpath:/com/example/beans-thread.xml";
          // 手动创建容器
          ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(){
                  @Override
                  protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
                      // 向容器中注册自定义的scope
                      beanFactory.registerScope(ThreadScope.THREAD_SCOPE, new ThreadScope()); // @1
                      supper.postProcessBeanFactory(beanFactory);
                  }
              };
          // 读取配置文件位置
          context.setConfigLocation(beanXml);
          // 启动容器
          context.refresh();
          // 使用容器获取bean
          for (int i = 0; i < 2; i++) { // @2
              new Thread(() -> {
                      System.out.println(Thread.currentThread() + "," + context.getBean("threadBean"));
                      System.out.println(Thread.currentThread() + "," + context.getBean("threadBean"));
              }).start();
              TimeUnit.SECONDS.sleep(1);
          }
      }
  }
#+end_src
** 总结
1. spring容器自带的有两种作用域，分别是singleton和prototyp,还有三种分别是 spring web 容器环境中才支持的request,session, application
2. singleton是spring容器默认的作用域，一个spring容器中同名的bean实例只有一个，多次获取得到的是同一个bean;单线程的bean需要考虑线程安全问题。
3. prototype是多例的，每次从容器中获取同名的bean，都会重新创建一个；多例bean使用的时候需要考虑创建bean对性能的影响。
4. 一个应用中可以有多个spring容器
5. 自定义scope 3个步骤，实现Scope接口，将实现类注册到spring容器，使用自定义的sope

* 依赖注入之手动注入
** 什么是依赖
通常情况下，系统中类和类之间是有依赖关系的，如果一个类对外提供的功能需要通过调用其它类的方法来实现的时候，说明这两个类之间存在依赖关系。
*** 依赖对象的初始化方式
+ 通过构造器设置依赖对
+ 通过set方法设置依赖对象
** spring依赖注入
*** 通过构造器注入
构造器的参数就是被依赖的对象，狗在其注入又分为3种注入方式：
+ 根据构造器参数索引注入
+ 根据构造器参数类型注入
+ 根据构造器参数名称注入
**** 根据构造器参数索引注入
***** 用法
#+begin_src xml
  <bean id="" class="">
    <constructor-arg index="0" value="上海"></constructor-arg>
    <constructor-arg index="1" value="沈阳"></constructor-arg>
    <constructor-arg index="2" value="武汉"></constructor-arg>
  </bean
#+end_src
+ constructor-arg 用户指定构造器的参数
+ index:构造器参数的位置
+ value:构造器参数的值，value只能用来给简单的参数设置值，value对应的属性类型只能为byte,int,long,float,double,boolean,
  Byte,Long,Float,Double,枚举,spring容器内部注入的时候会将value的值转换为对应的类型
***** 优缺点
1. 参数位置的注入对参数的顺序有很强的依赖性，若构造函数的参数位置被人调整过，会导致注入出错
2.通常情况下，不建议去代码中修改构造函数，如果愮新增参数的，可以新增一个构造函数来实现，这算是一个扩展，不会影响目前已有的功能。
**** 根据构造器参数类型注入
***** 用法
#+begin_src xml
  <bean id="" class="">
    <constructor-arg type="参数类型" value="参数值"></constructor-arg>
    <constructor-arg type="参数类型" value="参数值"></constructor-arg>
    <constructor-arg type="参数类型" value="参数值"></constructor-arg>
  </bean>
#+end_src
+ constructor-arg:用户指定构造器的参数
+ type:构造器参数的完整类型，如：java.lang.String,int,double
+ value:构造器参数的值，value只能用来给简单的类型设置值
***** 有缺点
实际上按照参数位置或者按照参数的类型注入，都有一个问题，很难通过bean的配置文件知道这个参数是对应UserModel种的哪个属性的，代码的可读性不好，
比如我想知道这每个参数对应的UserModel中的哪个属性，必须要去看UserModel源码。

**** 根据构造器参数名称注入
***** 用法
#+begin_src xml
  <bean id="" class="">
    <constructor-arg name="参数类型" value="参数值"></constructor-arg>
    <constructor-arg name="参数类型" value="参数值"></constructor-arg>
    <constructor-arg name="参数类型" value="参数值"></constructor-arg>
  </bean>
#+end_src
+ constructor-arg:用户指定构造器的参数
+ name:构造参数名称
+ value:构造器参数的值，value只能用来给简单的类型设置
****** 关于方法参数名称的问题
java通过反射的方式可以获取到方法的参数名称，不过源码中的参数通过编译之后会变成class对象，通常情况下源码变成class文件之后，
参数的真实名称会丢失，参数的名称会变成arg0，arg1,arg2,这样的，和实际的参数名称不一样了， *如果需要将源码中的参数名称保留在编译之后的class文件中，编译
的时候需要用到下面的命令*
#+begin_src shell
  javac -parameters java源码
#+end_src
但是我们难以保证编译代码的时候，操作人员一定会带上 *-parameters* 参数，所以方法的参数可能在class文件中会对视，导致反射获取到的参数名称和实际参数名称不符，
这个需要我们先了解一下。

参数名称可能不稳定的问题，spring提供了解决方案，通过Constructorproperties注解来定义参数的名称，将这个注解加在构造方法上面：
#+begin_src java
  @ConstructorProperties({"第一个参数名称", "第二个参数的名称",..."第n个参数的名称"})
  public 类名(String p1, String p2...,参数n) {}
#+end_src
*** setter注入
通常情况下，我们的类都是标准的javabean,javabean类特点：
+ 属性都是private级别的
+ 属性通常情况下通过一组setter，getter方法来访问
+ setter方法，以set开头后跟首字母大写的属性名，如： *setUserName* ,简单属性一般只有一个方法参数，方法返回值通常为void;
+ getter方法，一般属性以get开头，对于boolean类型一般以is开头，后跟首字母大写的属性名，如： *getUserName,isOk*;

spring对符合javabean特点的类,提供了setter方法的注入，会调用对应属性的setter方法将被以来的对象注入进去。
**** 用法
#+begin_src xml
  <bean id="" class="">
    <property name="属性名称" value="属性值"></property>
    <property name="属性名称" value="属性值"></property>
    <property name="属性名称" value="属性值"></property>
    <property name="属性名称" value="属性值"></property>
  </bean>
#+end_src
+ property: 用于对属性的值进行配置，可以有多个
+ name: 属性的名称
+ value：属性的值
**** 优缺点
setter注入相对于构造函数注入要灵活一些，构造函数需要指定对应构造函数中所有参数的值，而setter注入的方式没有这种限制，不需要对所有的属性
都进行注入，可以按需进行注入

*** 注入特殊类型的对象
**** 注入容器中的bean
注入容器中的bean的有两种写法
+ ref属性方式
+ 内置bean的方式
***** ref属性方式
将上面介绍的constructor-arg或者property元素的value属性名称替换为ref,ref属性的值为容器中其它bean的名称

构造器方式，将value替换为ref
#+begin_src xml
  <constructor-arg ref="需要注入的bean的名称" />
#+end_src
setter方式，将value替换为ref
#+begin_src xml
  <property name="属性名称" ref="需要注入的bean名称" />
#+end_src
***** 内置bean的方式
构造器方式：
#+begin_src xml
  <constructor-arg
      <bean class="" />
  </constructor-arg>
#+end_src
setter方式：
#+begin_src xml
  <property>
    <bean class="" />
  </property>
#+end_src
*** 其它常见类型注入详解
**** 注入java.util.List(List元素)
#+begin_src xml
  <list>
    <value>spring</value>

    <ref bean="bean名称"/>

    <list></list>

    <bean></bean>

    <array></array>

    <map></map>

  </list>
#+end_src
**** 注入java.util.Set(Set元素)
#+begin_src xml
  <set>
    <value>spring</value>

    <ref bean="bean名称"/>

    <list></list>

    <bean></bean>

    <array></array>

    <map></map>

  </set>
#+end_src
**** 注入java.util.Map(Map元素)
#+begin_src xml
  <map>
    <entry key="aaa" value="30" key-ref="key引用的bean名称" value-ref="value引用的bean名称"></entry>
    <entry>
      <key>
        value对应的值，可以为任意类型
      </key>
      <value>
        value对应的值，可以为任意类型
      </value>
    </entry>
  </map>

#+end_src
**** 注入数组(array数组)
#+begin_src xml
  <array>
    数组中的元素
  </array>
#+end_src
**** 注入java.util.Properties(Props元素)
Properties类相当于键值都是String类型的Map对象，使用props进行注入，如下：
#+begin_src xml
  <props>
    <prop key="key1">value1</prop>
    <prop key="key2">value2</prop>
    <prop key="key3">value3</prop>
  </props>
#+end_src
**** 案例
diOtherTypeModel.java
#+begin_src java
  public class DiOtherTypeModel {
      private List<String> list1;
      private Set<UserModel> set1;
      private Map<String, Integer> map1;
      private int[] array1;
      private Properties properties1;
      public List<String> getList1() {
          return list1;
      }
      public void setList1(List<String> list1) {
          this.list1 = list1;
      }
      public Set<UserModel> getSet1() {
          return set1;
      }
      public void setSet1(Set<UserModel> set1) {
          this.set1 = set1;
      }
      public Map<String, Integer> getMap1() {
          return map1;
      }
      public void setMap1(Map<String, Integer> map1) {
          this.map1 = map1;
      }
      public int[] getArray1() {
          return array1;
      }
      public void setArray1(int[] array1) {
          this.array1 = array1;
      }
      public Properties getProperties1() {
          return properties1;
      }
      public void setProperties1(Properties properties1) {
          this.properties1 = properties1;
      }
      @Override
      public String toString() {
          return "DiOtherTypeModel{" +
              "list1=" + list1 +
              ", set1=" + set1 +
              ", map1=" + map1 +
              ", array1=" + Arrays.toString(array1) +
              ", properties1=" + properties1 +
              '}';
      }
  }
#+end_src
diOtherType.xml
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">
    <bean id="user1" class="com.example.UserModel"/>
    <bean id="user2" class="com.example.UserModel"/>
    <bean id="diOtherType" class="com.example.DiOtherTypeModel">
      <!-- 注入java.util.List对象 -->
      <property name="list1">
        <list>
          <value>Spring</value>
          <value>SpringBoot</value>
        </list>
      </property>
      <!-- 注入java.util.Set对象 -->
      <property name="set1">
        <set>
          <ref bean="user1"/>
          <ref bean="user2"/>
          <ref bean="user1"/>
        </set>
      </property>
      <!-- 注入java.util.Map对象 -->
      <property name="map1">
        <map>
          <entry key="路人甲Java" value="30"/>
          <entry key="路人" value="28"/>
        </map>
      </property>
      <!-- 注入数组对象 -->
      <property name="array1">
        <array>
          <value>10</value>
          <value>9</value>
          <value>8</value>
        </array>
      </property>
      <!-- 注入java.util.Properties对象 -->
      <property name="properties1">
        <props>
          <prop key="key1">java高并发系列</prop>
          <prop key="key2">mybatis系列</prop>
          <prop key="key3">mysql系列</prop>
        </props>
      </property>
    </bean>
  </beans>
#+end_src
** 总结
1. 本文主要讲解了xml中bean的依赖注入，都是采用硬编码的方式进行注入的这种算是手动的方式
2. 注入普通类型通过value属性或者value元素设置注入的值；注入对象如果是容器中的其它bean时候，需要使用ref属性，或者ref元素或者内置bean元素的方式
3. 还介绍了其它几种类型List,Set,Map,数组,properties类型的注入。

* 依赖注入之自动注入(autowire)详解
** 手动注入不足
所谓手动注入就是指在xml中采用硬编码的方式来配置注入的对象，比如通过构造器注入或者set方法注入，这些注入的方式都存在不足。
+ 如果需要注入的对象比较多，比如A类中有几十个属性是不是需要写几十个，此时配置文件中的代码量暴增。
+ 如果A类新增或删除一些依赖，还需要手动去调整bean xml中的依赖配置信息，否则会报错
+ 总的来说就是不利于维护和扩展

为了解决上面的问题，spring为我们提供了更加强大的功能，自动注入
** Class.isAssignableFrom方法
*** 用法
isAssignableFrom方法是Class类中的一个方法，看一下这个方法的定义
#+begin_src java
  public native boolean isAssignableFrom(Class<?> cls)
#+end_src
用法如下：
#+begin_src java
  cl.isAssignableFrom(c2);
#+end_src
用来判断C2和c1是否相等，或者c2是否是c1的子类。
** 自动注入
自动注入是采用约定大于配置的方式来实现的，程序和spring容器之间约定好，遵守某一种都认同的规矩，来实现自动注入。

xml中可以在bean元素中通过 *autowire* 属性来设置自动注入的方式：
#+begin_src xml
  <bean id="" class="" autowire="byType|byName|constructor|default" />
#+end_src
+ byName: 按照名称进行注入
+ byType: 按照类型进行注入
+ constructor: 按照构造方法进行注入
+ default: 按照默认注入方式
*** 按照名称进行注入(byName)
**** 用法
#+begin_src xml
<bean id="" class="x类" autowire="byName"
#+end_src
spring容器会按照set属性的名称去容器中查找同名的bean对象，然后将查找到的对象通过set方法注入到对应的bean中，未找到对应的名称的bean对象
则set方法不进行注入。

需要注入的set属性的名称和被注入的bean的名称必须保持一致。
**** 优缺点
按照名称进行注入的时候，要求名称和set属性的名称必须同名，相对于硬编码的方式注入，确实节省了不少的代码。
*** 按照类型进行自动注入
**** 用法
#+begin_src xml
  <bean id="" class="x类" autowire="byType"
#+end_src
spring容器会遍历x类中的所有set方法，会在容器中查找和set参数类型相同的bean对象，将其通过set方法进行注入，未找到对应类型的bean对象
则set方法不进行注入。

*需要注入的set属性的类型和被注入的bean的类型需要满足isAssignableFrom关系*

按照类型自动装配的时候，如果按照类型找到了多个符合条件的bean，系统就会报错。

*set方法的参数如果是下面的类型或者下面类型的数组的时候，这个set方法会被跳过注入* ：
#+begin_src java
  Object;
  Boolean;
  boolean;
  Byte;
  byte;
  Character;
  char;
  Double;
  double;
  Float;
  float;
  Integer;
  int;
  Long;
  long;
  Short;
  short;
  Enum;
  CharSequence;
  Number;
  Date;
  java.time.temportal.Temporal;
  java.net.URI;
  java.util.Locate.lang.Class;
#+end_src
**** 优缺点
相对于手动注入，节省了不少代码，新增或者删除属性，只需要增加或减少对应的set方法就可以了，更容易扩展了。

*** 注入类型匹配的所有bean(*重点*)
**** 按照类型注入还有两个比较牛逼的用法
+ 一个容器中满足某种类型的bean可以有很多个，将容器中某种类型中的所有bean,通过set方法注入
  给一个java.util.List<需要注入的Bean的类型或者其父类型或者其接口对象>
+ 将容器中某种类型中的所有bean,通过set方法注入给java.util.Map<String,需要注入的Bean的类型或者其父类型或者其接口对象>
**** 案例
DiAutowireByTypeExtend.java
#+begin_src java
  import java.util.List;
  import java.util.Map;
  /**
   ,*满足条件的bean注入到集合中(重点)
   ,*/
  public class DiAutowireByTypeExtend {
      // 定义了一个接口
      public interface IService1 {}

      public static class BaseServie{
          private String desc;
          public String getDesc() {
              return desc;
          }
          public void setDesc(String desc) {
              this.desc = desc;
          }
          @overide
          public String toString(){
              return "BaseService{desc=" + desc + "}";
          }
      }
      // Service1实现了IService1接口
      public static class Service1 extends BaseService implements IService1 {}

      // Service2实现了IService1接口
      public static class Service2 extends BaseService implements IService1 {}

      private List<IService1> serviceList; //@1
      private List<BaseService> baseServiceList; //@2
      private Map<String,IService1> serviceMap; // @3
      private Map<String,BaseService> baseServiceMap; //@4

      public List<IService1> getServiceList() {
          return serviceList;
      }

      public void setServiceList(List<IService1> serviceList) { // @5
          this.serviceList = serviceList;
      }

      public List<BaseService> getBaseServiceList() {
          return baseSreviceList;
      }

      public void setBaseServiceList(List<BaseService> baseServiceList) { //@6
          this.baseServiceList = baseServiceList;
      }
      public Map<String, IService1> getService1Map() {
          return service1Map;
      }
      public void setService1Map(Map<String, IService1> service1Map) {//@7
          this.service1Map = service1Map;
      }
      public Map<String, BaseServie> getBaseServieMap() {
          return baseServieMap;
      }
      public void setBaseServieMap(Map<String, BaseServie> baseServieMap) {//@8
          this.baseServieMap = baseServieMap;
      }
      @Override
      public String toString() { //9
          return "DiAutowireByTypeExtend{" +
              "serviceList=" + serviceList +
              ", baseServieList=" + baseServieList +
              ", service1Map=" + service1Map +
              ", baseServieMap=" + baseServieMap +
              '}';
      }
  }
#+end_src
+ @1,@2,@3,@4 定义了四个属性，都是反省类型的，都有对应的set方法。
+ @5： 参数类型是List<BaseService>,这个集合中元素的类型是BaseService,spring会找到容器中所有满足BaseService.isAssignableFrom(bean的类型)的
  bean列表，将其通过@5的set方法进行注入。
+ @6： 通@5代码
+ @7： 这个参数类型是一个map了，map的key是String类型，value是IService类型，spring容器会将所有满足IService1类型的bean找到，
  按照name->bean对象这种方式丢到一个map中，然后调用@7的set方法进行注入，最后注入的这个map就是bean的名称和bean对象进行映射的一个map对象。
+ @8： 通@7代码
+ @9： 重写了toString方法，

*** 按照构造函数进行自动注入
**** 用法
#+begin_src xml
  <bean id="" class="x类" autowire="constructor" />
#+end_src
spring会扎到x类中所有的构造方法(一个类可能有多个构造方法)，然后将这些构造方法进行排序（先按照修饰符进行排序，public在前面，其它的在后面，如果修饰符
一样，会按照构造函数参数数量倒叙，也就是采用贪婪的模式进行匹配，spring容器会尽量多注入一些需要的对象）得到一个构造函数列表，会轮询这个构造器列表，
判断当前构造器所有参数是否在容器中都可以找到匹配的bean对象，如果可以找到就使用这个构造器进行注入，如果不能找到，那么就会跳过这个构造器，继续采用同样的方式
匹配下一个构造器，知道找到一个何时的为止。
*** autowire=default
**** 用法
bean xml 的根元素为beans,注意根元素有个default-autowire属性，这个属性可选值有 *no|byName|byType|constructor|default* ,这个属性可以批量设置当前文件中所有bean的自动注入的方式，
bean元素中如果省略了autowire属性，那么会取default-autowire的值作为其autowire的值，而每个bean元素还可以单独设置自己的autowire覆盖default-autowire的配置，如下：
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd"
         default-autowire="byName">
  </beans>
#+end_src
**

** 总结
+ xml中手动注入存在的不足，可以通过自动注入的方式来解决
+ 按照类型注入中有个比较重要的是注入匹配类型所有的bean，可以将某种类型所有的bean注入给一个List对象，可以将某种类型的所有bean按照bean名称->bean对象
  的映射方式注入给一个Map对象，这种方法比较重要，用途比较大。
+ spring中还有其它自动注入的方式。

* depend-on
干预bean的创建和销毁的顺序
** 无任何依赖bean创建和销毁顺序
| bean定义顺序 | 创建顺序 | 销毁顺序 |
|--------------+----------+----------|
| bean3        | bean3    | bean1    |
| bean2        | bean2    | bean2    |
| bean1        | bean1    | bean3    |

+ bean对象的创建顺序和bean xml中定义顺序一致
+ bean销毁的顺序和bean xml中定义的顺序相反
** 通过构造器强依赖bean创建和销毁顺序
依赖关系是bean3->bean2->bean1
| bean定义顺序 | 依赖顺序（下面依赖上面的） | 创建顺序 | 销毁顺序 |
|--------------+----------------------------+----------+----------|
| bean3        | bean1                      | bean1    | bean3    |
| bean2        | bean2                      | bean2    | bean2    |
| bean1        | bean3                      | bean3    | bean1    |
+ bean对象的创建顺序和bean依赖的顺序一致
+ bean销毁的顺序和bean创建的顺序相反
** 通过depend-on干预bean创建和销毁顺序
上面看到了，对于无依赖的bean，通过定义的顺序确实可以干预bean的创建顺序，通过强依赖也可以干预bean的创建顺序。

那么如果xml中定义的bean特别多，而有些bean之间也没有强依赖关系，此时如果想去调整bean的创建和销毁顺序，得去调整xml中bean的定义顺序，或者去加强依赖，
这样是非常不好的，spring中可以通过 *depend-on* 来解决这些问题，在不调整bean的定义顺序和强加依赖的情况下，可以通过 *depend-on* 属性来设置当前bean的依赖于
哪些bean,那么可以保证depend-on指定的bean在当前bean之前创建好，销毁的时候在当前bean之后进行销毁。

*** depend-on使用方式：
#+begin_src xml
  <bean id="bean1" class="" depend-on="bean2,bean3;bean4" />
#+end_src
depend-on: 设置当前bean依赖的bean名称，可以指定多个，多个之间可以用 *, ; 空格*  进行分割，上面不管bean2,bean3,bean4在任何地方定义，都可以确保在bean1创建
之前，会先将bean2,bean3,bean4创建好，表示bean1依赖于这三个bean,可能bean1需要用到bean2,bean3,bean4中生成的一些资源或者其它功能等，但是又没有强制去在
bean1类中通过属性定义强依赖的方式去依赖于bean2,bean3,bean4,当然销毁的时候也会先贤惠当前bean,再去销毁被依赖的bean,即先销毁bean1,再去销毁depend-on中指定的bean。


** 总结
1. 无依赖的bean创建顺序和定义顺序一致，销毁顺序刚好相反
2. 通过构造器强依赖的bean，会先创建构造器参数中对应的bean,然后才会创建当前bean,销毁顺序刚好相反
3. depend-on可以指定当前bean依赖的bean,通过这个可以确保depend-on指定的bean在当前bean之前先创建好，销毁顺序刚好相反
* primary可以解决什么问题？
** 问题提出
当spring容器中定义了多个bean，分别是serviceA和serviceB......,这两个bean对象都实现了IService接口，此时想从容器中获取Service接口对应的bean，
此时容器中有多个候选者（servceA,serviceB,serviceC.....）满足我们的需求，此时spring容器不知道如何选择，到底是返回哪一个，spring懵了，就会报错。
** 解决方案
spring中可以通过bean元素的primary这个属性来解决问题，可以通过这个属性来指定当前bean为主要候选者，当容器中查询一个bean的时候，如果容器中有多个后选者匹配的时候，
此时spring会返回主要的后选者。
** 示例：
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">

    <bean id="serviceA" class="com.demo8.PrimaryBean$ServiceA" primary="true"/>
    <bean id="serviceB" class="com.demo8.PrimaryBean$ServiceA"/>

  </beans>
#+end_src
* autowire-candidate属性
解决自动注入时，出现多个相同类型的类，无法注入问题

设置某个bean是否在自动注入的时候是否为作为候选bean，通过bean元素的autowire-candidate属性来配置。
* lazy-init: bean延迟初始化
** bean初始化两种方式
+ 实时初始化
+ 延迟初始化
*** bean实时初始化
在容器启动过程中被创建组装好的bean，称为实时初始化的bean，spring中默认定义的bean都是实时初始化的bean，这些bean默认都是单例的，在容器启动过程中会被创建好，
然后放在spring容器中以供使用
**** 优点
1. 更早发下bean定义的错误：实时初始化的bean如果定义有问题，会在容器启动过程中抛出异常，让开发者快速发现问题。
2. 查找bean更快：容器启动完毕之后，实时初始化的bean已经完全创建好了，此时被缓存在spring容器中，当我们需要使用的时候，容器直接
  返回就可以了，速度是非常快的。
*** bean延迟初始化
实时初始化的bean都会在容器启动过程中创建好，如果程序中定义的bean非常多，并且有些bean创建的过程中比较耗时的时候，会导致系统消耗的资源比较多，
并且会让整个启动时间比较长。

针对以上问题，spring对这些问题提供了解决方案: *bean延迟初始化* 。

所谓延迟初始化，就是和实时初始化刚好相反，延迟初始化的bean在容器启动过程不会创建，而是需要的时候才会去创建，那么bean什么时候会被使用？
1. 被其它bean作为依赖进行注入的时候,比如通过property元素的ref属性进行引用，通过构造器注入，通过sett注入，通过自动注入，这些都会导致被依赖bean的创建。
2. 开发者自己写代码向容器中查找bean的时候，如调用容器的getBean方法获取bean.
**** 延迟bean的配置
#+begin_src xml
<bean lazy-init="true/false" />
#+end_src
* 使用继承简化bean的配置(abstract & parent)
** 案例引入
ServiceA.java
#+begin_src java
  public class ServiceA{}
#+end_src
ServiceB.java
#+begin_src java
  public class ServiceB {
      private String name;
      private ServiceA serviceA;
      public String getName() {
          return name;
      }
      public void setName(String name) {
          this.name = name;
      }
      public ServiceA getServiceA() {
          return serviceA;
      }
      public void setServiceA(ServiceA serviceA) {
          this.serviceA = serviceA;
      }
      @Override
      public String toString() {
          return "ServiceB{" +
              "name='" + name + '\'' +
              ", serviceA=" + serviceA +
              '}';
      }
  }
#+end_src
ServiceC.java
#+begin_src java
  public class ServiceC {
      private String name;
      private ServiceA serviceA;
      public String getName() {
          return name;
      }
      public void setName(String name) {
          this.name = name;
      }
      public ServiceA getServiceA() {
          return serviceA;
      }
      public void setServiceA(ServiceA serviceA) {
          this.serviceA = serviceA;
      }
      @Override
      public String toString() {
          return "ServiceB{" +
              "name='" + name + '\'' +
              ", serviceA=" + serviceA +
              '}';
      }
  }
#+end_src
beanExtend.xml
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">
    <bean id="serviceA" class="com.demo12.ServiceA"/>
    <bean id="serviceB" class="com.demo12.ServiceB">
      <property name="name" value="·Java1"/>
      <property name="serviceA" ref="serviceA"/>
    </bean>
    <bean id="serviceC" class="com.demo12.ServiceB">
      <property name="name" value="Java2"/>
      <property name="serviceA" ref="serviceA"/>
    </bean>
  </beans>
#+end_src
BeanExtendTest.java
#+begin_src java
  public class BeanExtendTest {
      @Test
      public void normalBean() {
          String beanXml ="classpath:/com/demo12/normalBean.xml";
          ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(beanExtend.xml);
          System.out.println("serviceB:" + context.getBean(ServiceB.class));
          System.out.println("serviceC:" + context.getBean(ServiceC.class));
      }
  }
#+end_src
运行结果为：
#+begin_src shell
  serviceB:ServiceB{name='Java1',serviceA=com.javacode2018.demo12.ServiceA@222114ba}
  serviceC:ServiceC{name='Java2',serviceA=com.javacode2018.demo12.ServiceA@222114ba}
#+end_src
** 通过继承优化代码
上面xml中有两个bean，serviceB和serviceC,这两个bean需要注入的属性值是一样的，都需要注入name和serviceA这两个属性，并且两个属性的值
也一样，我们可以将上面的代码抽取出来，通过spring中继承的方式来做到代码的重用。

xml更改如下：
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">
    <bean id="serviceA" class="com.demo12.ServiceA"/>
    <bean id="baseService" abstract="true">
      <property name="name" value="Java1"/>
      <property name="serviceA" ref="serviceA"/>
    </bean>
    <bean id="serviceB" class="com.demo12.ServiceB" parent="baseService"/>
    <bean id="serviceC" class="com.demo12.ServiceC" parent="baseService"/>
  </beans>
#+end_src
上面多了一个baseService的bean,这个bean没有指定class对象，但是多了一个abstract="true"的属性，表示这个bean是抽象的，abstract
为true的bean在spring容器中不会被创建，只是会将其当作bean定义的模板，而serviceB和serviceC的定义中多了一个属性parent，用来指定
当前bean的父bean名称。

子bean中也可以重新定义父bean中已经定义好的配置，这样子配置会覆盖父bean中的配置信息。

* lookup-method和replaced-method
** lookup-method: 方法查找
通常情况下，我们使用的bean都是单例的，如果一个bean需要依赖于另一个bean的时候，可以在当前bean中声明另外一个bean引用，然后注入依赖的bean,
此时被依赖的bean在当前bean中自始至终都是同一个实例。
*** 案例回顾
#+begin_src java
  public class ServiceA {}

  public class ServiceB {
      private ServiceA serviceA;

      public ServiceA getServiceA() {
          return serviceA;
      }
      public void setServiceA(ServiceA serviceA) {
          this.serviceA = serviceA;
      }
  }
#+end_src
bean.xml
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">

    <bean id="serviceA" class="com.demo13.normal.ServiceA" scope="prototype"/>
    <bean id="serviceB" class="com.demo13.normal.ServiceB">
      <property name="serviceA" ref="serviceA"/>
    </bean>
  </beans>
#+end_src
上面serviceA的scope是prototype，表示serviceA是多例的，每次从容器中获取serviceA都会返回一个新的对象。

而serviceB的scope没有配置，默认是单例的，通过prototype元素将service注入。

如果我们希望beanB中每次使用beanA的时候beanA都是一个新的实例，我们可以在serviceB中价格方法去获取ServiceA,这个方法中我们主动去容器中
获取serviceA，每次获取到的都是不同的serviceA实例。

那么，如何在serviceB中获取到spring容器呢？

spring中有个接口ApplicationContextAware:
#+begin_src java
  org.springframework.context.ApplicationContextAware;
  public interface ApplicationContextAware extends Aware {
    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
  }
#+end_src
上面这个接口有个方法 *setApplicationContext* ,这个接口给了自定义的bean中获取applicationContext的能力，当我们的类实现这个接口之后，spring容器
创建bean对象的时候bean实现了这个接口，那么容器会自动调用 *setApplicationContext* 方法，将容器对象applicationContext传入，此时在我们bean
对象中就可以使用容器的任何方法了。
*** 单例bean中使用多例bean:ApplicationContext接口的方式
serviceA.java
#+begin_src java
  public class serviceA{}
#+end_src
serviceB.java
#+begin_src java
  public class ServiceB implements ApplicationContextAware { //@1
      public void say() {
          ServiceA serviceA = this.getService(); //@2
          System.out.println("this:"+this+",serviceA:"+ serviceA);
      }
      public ServiceA getServiceA() {
          return this.context.getBean(ServiceA.class);//@3
      }
      private ApplicationContext context;
      @Override
      public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
          this.context = applicationContext;
      }
  }
#+end_src
上面代码，serviceB实现了ApplicationContextAware接口，然后实现了这个接口中的setApplicationContext方法，spring容器在创建ServiceB的时候会自动调用
setApplicationContext方法。

@3： 从容器中主动获取ServiceA, 这样每次获取到的ServiceA都是一个新的实例。

@2： say方法中调用getServiceA方法获取ServiceA对象，然后将其输出。

*** 单例bean中使用多例bean: lookup-method方式实现
上面这种方式实现了单例bean中使用多例bean的需求，但是用到spring中的接口 *ApplicationContextAware* ,此时对spring的
api有耦合的作用，我们一直推行高内聚低耦合，所以应该寻求更好的办法。------->lookup-method
serviceA.java
#+begin_src java
  public class ServiceA {}
#+end_src
serviceB.java
#+begin_src java
  public class ServiceB {
      public void say() {
          ServiceA serviceA = this.getServiceA();
      }

      public ServiceA getServiceA() { //@1
          return null;
      }
  }
#+end_src
上面@1，这个方法中返回了一个null对象，下面我们通过spring来创建上面2个bean对象，然后让spring对上面的getServiceA方法进行拦截，
返回指定的bean，如下：
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">

    <bean id="serviceA" class="com.demo13.lookupmethod.ServiceA" scope="prototype"/>
    <bean id="serviceB" class="com.demo13.lookupmethod.ServiceB">
      <lookup-method name="getServiceA" bean="serviceA"/>
    </bean>
  </beans>
#+end_src
重点在于 *lookup-method* 这一行的配置，当我们调用serviceB中的getServiceA方法的时候，这个方法会拦截，然后会按照
lookup-method元素中bean属性的值作为bean的名称去容器中查找对应的bean，然后作为getServiceA的返回值返回，即调用
getServiceA方法的时候，会从spring容器中查找id为serviceA的bean然后返回。

** replaced-method: 方法替换
replace-method:方法替换，比如我们要调用serviceB中的getServiceA的时候，我们可以对ServiceB这个bean中的getServiceA方法进行拦截，
把这个调用请求转发到一个替换者处理，这就是replaced-method可以实现的功能，比lookup-method更强大更灵活。
*** replaced-method的使用3个步骤
**** 定义替换者
自定义一个替换者，替换者需要实现spring中的MethodReplacer接口，接口定义如下：
#+begin_src java
  public interface MethodReplacer {
    /**
     * @param obj 被替换方法的目标对象
     * @param method 目标对象的方法
     * @param args 方法的参数
     * @return return value for the method
     */
    Object reimplement(Object obj, Method method, Object[] args) throws Throwable;
  }
#+end_src
当调用目标对象需要被替换的方法的时候，这个调用请求会被转发到上面的替换者的reimplement方法进行处理。
#+begin_src java
  // serviceB的方法替换者
  public class ServiceBMethodReplacer implements MethodReplacer,ApplicationContextAware {
      @Override
      public Object reimplement(Object obj, Method method, Object[] args) throw Throwable {
          return this.context.getBean(ServiceA.class);
      }
      private ApplicationContext context;
      @Override
      public void setApplicationContext(ApplicationContext applicationContext)
          throws BeansException {
          this.context = applicationContext;
      }
  }
#+end_src
**** 定义替换者bean
#+begin_src java
  <bean id="serviceBMethodReplacer" class="com.demo14.ServiceBMethodReplacer" />
#+end_src
**** 通过replaced-method元素配置目标bean需要被替换的方法
#+begin_src xml
  <bean id="serviceB" class="com.demo14.ServiceB">
    <replaced-method name="getServiceA" replacer="serviceAMethodReplacer"/>
  </bean>
#+end_src
+ name: 用于指定当前bean需要被替换的方法
+ replacer: 替换者，即实现了MethodReplace接口的类对应的bean
xml配置中当调用serviceB的getServiceA的时候，会自动调用serviceAMethodReplacer这个bean中的
reimplement方法进行处理。

* 代理详解（java动态代理&CGLIB代理）
** jdk动态代理详解
jdk中为实现代理提供了支持，主要用到两个类
#+begin_src java
  java.lang.reflect.Proxy;
  java.lang.reflect.InvocationHandler;
#+end_src
jdk自带的代理使用上面有个限制，只能为接口创建代理，如果需要给具体的类创建代理类，需要用cglib
*** java.lang.reflect.Proxy
这是jdk动态代理中主要的一个类，里面有一些静态方法会经常用到
**** getProxyClass方法
为指定的接口创建代理类，返回代理类的Class对象
#+begin_src java
  public static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces);
#+end_src
参数说明：
+ loader: 定义代理类的类加载器
+ interfaces: 指定需要实现的接口列表，创建的代理默认会按顺序实现interfaces指定的接口
**** newProxyInstance方法
创建代理类的实例对象
#+begin_src java
  public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
#+end_src
这个方法先为指定的接口创建代理类，然后会生成代理类的一个实例，最后一个参数比较特殊，是InvocatonHandler类型的，这个是个接口如下：
#+begin_src java
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
#+end_src
上面方法会返回一个代理对象，当调用代理对象的任何方法的时候，会被InvocationHandler接口的invoke方法处理，所以主要代码需要写在invoke方法中。
*** isProxy方法
判断指定的类是否是一个代理类
#+begin_src java
  public static boolean isProxyClass(Class<?> cl);
#+end_src
*** getInvocationHandler方法
获取代理对象的InvocationHandler对象
#+begin_src java
  public static InvocationHandler getInvocationHandler(Object proxy) throws IllegalArgumentException;
#+end_src

*** 创建代理：方式1
**** 步骤
1. 调用Proxy.getProxyClass方法获取代理类的Class对象
2. 使用InvocationHandler接口创建代理类的处理器
3. 通过代理类和InvocationHandler创建代理对象
4. 使用代理对象了
**** 案例
创建接口IService
#+begin_src java
  public interface IService {
      void m1();
      void m2();
      void m3();
  }
#+end_src
创建IService接口的代理对象
#+begin_src java
  @Test
  public void m1() throws NoSuchMethodException,IllegalAccessException,InvocationTargetException,InstantiationException {
    // 1. 获取接口对应的代理类
    Class<IService> proxyClass = (Class<IService>)Proxy.getProxyClass(IService.class.getClassLoader(), IService.class);
    // 2. 创建代理类的处理器
    InvocationHandler invocationHandler = new InvocationHandler() {
            @override
            public Object invoke(Object proxy, Method method, Ojbect[] args) throws Throwable {
              System.out.println("我是InvocationHandler,被调用的方法是" + method.getName());
              return null;
            }
        };
    // 3. 创建代理实例
    IService proxyService = proxyClass.getConstructor(InvocationHandler.class).newInstance(invocationHandler);
    // 4. 调用代理的方法
    proxyService.m1();
    proxyService.m2();
    proxyService.m3();
  }

#+end_src
*** 创建代理：方式2
**** 步骤
1. 使用InvocationHandler接口创建代理类的处理器
2. 使用proxy类的静态方法newProxyInstance直接创建代理对象
3. 使用代理对象
**** 案例
#+begin_src java
  @Test
  public void m2() throws NoSuchMethodException,IllegalAccessException,InvocationTargetException,InstantiationException {
      //1. 创建代理处理器
      InvocationHandler invocationHandler = new InvocationHandler() {
              @override
              public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println("我是InvocationHandler,被调用的方法是" + method.getName());
                return null;
              }
          };
      // 2. 创建代理实例
      IService proxyService = (IService)Proxy.newProxyInstance(IService.class.getClassLoader(), new Class[]{IService.class}, invocationHandler);
      // 3. 调用代理的方法
      proxyService.m1();
      proxyService.m2();
      proxyService.m3();
  }

#+end_src

* java注解
** 什么是注解
注解是对代码的一种增强，可以在代码编译或者程序运行期间获取注解的信息，然后根据这些信息做各种你牛逼的事情
** 注解的使用方式
*** 步骤
1. 定义注解
2. 使用注解
3. 获取注解信息做各种牛逼的事情
*** 定义注解
**** 定义注解语法
jdk中注解相关的类和接口都定义于 java.lang.annotation 包中。

注解的定义和我们常见的类，接口类似，只是注解使用 @interface 来定义，如下定义一个名称为MyAnnotation的注解
#+begin_src java
  public @interface MyAnnotation{}
#+end_src
**** 注解中定义参数
注解中有没有参数都可以，定义参数如下：
#+begin_src java
  public @interface 注解名称 {
      [public] 参数类型 参数名称1() [default 参数默认值];
      [public] 参数类型 参数名称2() [default 参数默认值];
      [public] 参数类型 参数名称3() [default 参数默认值];

  }

#+end_src
注解中可以定义多个参数，参数的定义有以下特点：
1. 访问修饰符必须为public,不屑默认为public
2. 该元素的类型只能是基本数据类型，String,Class,枚举类型，注解类型(体现了注解的嵌套效果)以及上述类型的一位数组
3. 该元素的名称一般定义为名词，如果注解中只有一个元素，请把名字起为value(后面使用会带来便利操作)
4. 参数名称后面()不是定义方法参数的地方，也不能在括号中定义任何参数，仅仅只是一个特殊的语法。
5. default代表默认值，值比u和第二点定义的类型保持一致。
6. 如果没有默认值，代表后续使用注解时必须给该类型元素赋值。
**** 指定注解的使用范围： @Target
使用@Target注解定义注解的使用范围如下：
#+begin_src java
  @Target(value={ElementType.TYPE, ElementType.METHOD})
  public @interface MyAnnotation{}
#+end_src
上面指定了MyAnnotation注解可以用在类，接口，注解类型，枚举类型以及方法上面，自定义注解上也可以不使用@Target注解，如果不使用，表示自定义
注解可以用在任何地方。

下面看一下@Target源码：
#+begin_src java
  @Documented
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.ANNOTATION_TYPE)
  public @interface Target {
    ElementType[] value();
  }
#+end_src
有一个参数时value,时ElemtnType类型的一个数组，再来看一下ElementType,是个枚举，源码如下：
#+begin_src java
  pacage java.lang.annotation;
  public enum ElementType {
    /*类，接口，枚举，注解上面*/
    TYPE,
    /*字段上*/
    FIELD,
    /*方法上*/
    Mehtod,
    /*方法参数上*/
    PARAMETER,
    /*构造函数上*/
    CONSTRUCTOR,
    /*本地变量上*/
    LOCAL_VARIABLE,
    /*注解上*/
    ANNOTATION_TYPE,
    /*包上*/
    PACKAGE,
    /*类型参数上*/
    TYPE_PARAMETER,
    /*类型名称上*/
    TYPE_USE

  }
#+end_src

**** 指定注解的保留策略：@Retention
***** java程序的三个过程
1. 源码阶段
2. 源码被编译为字节码之后变成class文件
3. 字节码被虚拟机加载然后运行
***** 自定义保留策略
#+begin_src java
@Retention(RetentionPolicy.SOURCE)
public @interface MyAnnotation{}
#+end_src
上面指定了MyAnnotation只存在于源码阶段，后面的阶段都会丢失。

@Retention源码
#+begin_src java
  @Documented
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.ANNOTATION_TYPE)
  public @interface Retention {
      RetentionPolicy value();
  }

#+end_src
有一个value参数，类型为RetentionPolicy枚举，如下：
#+begin_src java
  public enum RetentionPolicy {
    /*注解值保留在源码阶段，编译为字节码之后就丢失了，也就是class文件中就不存在了*/
    SOURCE,
    /*注解只保留在源码和字节码中，运行阶段会丢失*/
    CLASS,
    /*源码，字节码，运行期间都存在*/
    RUNTIME
  }
#+end_src

*** 使用注解
**** 语法
将注解加载使用的目标上面，如下：
#+begin_src java
  @注解名称(参数1=值1，参数2=值2，参数n=值n)
  目标对象
#+end_src
**** 无参注解
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann1{ // @1
  }

  @Ann1 //@2
  public class UseAnnotation1{}

#+end_src
@1: Ann1为无参注解

@2：类上使用@Ann1注解，没有参数

**** 一个参数注解
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann2 { //@1
      String name();
  }
  @Ann2(name = "java1") //@2
  public class UseAnnotation2 {
  }
#+end_src
**** 一个参数为value的注解，可以省略参数名称
只有一个参数，名称为value的时候，使用时参数名称可以省略
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann3 {
      String value();//@1
  }
  @Ann3("java1") //@2
  public class UseAnnotation3 {
  }
#+end_src
@1: 注解之后的一个参数，名称为value。

@2：使用注解，参数名称value省略了

**** 数组类型参数
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann4 {
      String[] name();//@1
  }

  @Ann4(name = {"java1", "java2"}) //@2
  public class UseAnnotation4 {
      @Ann4(name = "如果只有一个值，{}可以省略}") //@3
      public class T1 {
      }
  }
#+end_src
@1: name的类型是一个String类型的数组

@2：name有多个值的时候，需要用{}包含起来

@3: 如果name只有一个值，{}可以省略
**** 为参数指定默认值
通过default为参数指定默认值，用的时候如果没有设置值，则取默认值的参数，使用的时候必须为参数设置值，如下
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann5 {
      String[] name() default {"java", "spring"};//@1
      int[] score() default 1; //@2
      int age() default 30; //@3
      String address(); //@4
  }
  @Ann5(age = 32,address = "上海") //@5
  public class UseAnnotation5 {}
#+end_src
@1： 数组类型通过{}指定默认值

@2： 数组类型参数，默认值只有一个省略了{}符号

@3： 默认值为30

@4： 未指定默认值

@5： age=32对默认值进行了覆盖，并且为address指定了值

*** 综合案例
#+begin_src java
  @Target(value = {ElementType.TYPE,ElementType.METHOD,ElementType.FIELD,ElementType.PARAMETER,ElementType.CONSTRUCTOR,ElementType.LOCAL_VARIABLE})
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann6 {
      String value();
      ElementType elementType();
  }


  @Ann6(value = "用在类上", elementType = ElementType.TYPE)
  public class UseAnnotation6 {
      @Ann6(value = "用在字段上", elementType = ElementType.FIELD)
      private String a;
      @Ann6(value = "用在构造方法上", elementType = ElementType.CONSTRUCTOR)
      public UseAnnotation6(@Ann6(value = "用在方法参数上", elementType = ElementType.PARAMETER) String a) {
          this.a = a;
      }
      @Ann6(value = "用在方法上", elementType = ElementType.METHOD)
      public void m1() {
          @Ann6(value = "用在了本地变量上", elementType = ElementType.LOCAL_VARIABLE) String a;
      }
  }
#+end_src
上面演示了自定义注解在类，字段，构造器，方法参数，方法，本地变量上的使用，@Ann6注解有个elementType参数，我想通过这个参数的值告诉大家
对应@Target中的那个值来限制使用目标的，注意以下上面每个elementType的值。

*** @Target(ElementType.TYPE_PARAMETER)
这个是1.8之后才有的，用来标注类型参数，类型参数一般在类后面声明或者方法上面声明，这块需要先了解以下泛型

案例：
#+begin_src java
  @Target(value = {ElementType.TYPE_PARAMETER})
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann7 {
      String value();
  }

  public class UseAnnotation7<@Ann7("T0是在类上声明的一个泛型类型变量") T0, @Ann7("T1是在类上声明的一个泛型类型变量") T1> {
      public <@Ann7("T2是在方法上声明的泛型类型变量") T2> void m1() {
      }
      public static void main(String[] args) throws NoSuchMethodException {
          for (TypeVariable typeVariable : UseAnnotation7.class.getTypeParameters()) {
              print(typeVariable);
          }
          for (TypeVariable typeVariable : UseAnnotation7.class.getDeclaredMethod("m1").getTypeParameters()) {
              print(typeVariable);
          }
      }
      private static void print(TypeVariable typeVariable) {
          System.out.println("类型变量名称:" + typeVariable.getName());
          Arrays.stream(typeVariable.getAnnotations()).forEach(System.out::println);
      }
  }
#+end_src
类和方法上面可以声明泛型类型的变量，下面是运行结果
#+begin_src java
  类型变量名称:T0
  @com.javacode2018.lesson001.demo18.Ann7(value=T0是在类上声明的一个泛型类型变量)
  类型变量名称:T1
  @com.javacode2018.lesson001.demo18.Ann7(value=T1是在类上声明的一个泛型类型变量)
  类型变量名称:T2
  @com.javacode2018.lesson001.demo18.Ann7(value=T2是在方法上声明的泛型类型变量)
#+end_src

*** @Target(ElementType.TYPE_USE)
这个是1.8加上的，能用在任何类型名称上面
#+begin_src java
  @Target({ElementType.TYPE_USE})
  @Retention(RetentionPolicy.RUNTIME)
  @interface Ann10 {
      String value();
  }
  @Ann10("用在了类上")
  public class UserAnnotation10<@Ann10("用在了类变量类型V1上") V1, @Ann10("用在了类变量类型V2上") V2> {
      private Map<@Ann10("用在了泛型类型上") String, Integer> map;
      public <@Ann10("用在了参数上") T> String m1(String name) {
          return null;
      }
  }
#+end_src
类后面的V1、V2都是类型名称，Map后面的尖括号也是类型名称，m1方法前面也定义了一个类型变量，名称为T

** 注解信息的获取
为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect反射包下新增了AnnotatedElement接口，他主要用于表示目前正在虚拟机中
运行的程序中已使用注解的元素，通过该接口提供的方法，可以利用反射技术读取注解的信息,UML图如下(实现类)
*** AnnotateElement
+ Method： 用来表示方法信息
+ TypeVariable: 用来表示类型变量信息，如：类上定义的泛型类型变量，方法上面定义的泛型类型变量
+ Class: 用来表示类的信息
+ Package: 用来表示包的信息
+ Field: 用来表示类中属性信息
+ Constructor: 用来表示构造方法信息
+ Parameter: 用来表示方法参数信息
*** AnnotateElement常用方法
| 返回值                 | 方法名称                                                         | 说明                                                                                                                                                      |
|------------------------+------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| <A extends Annotation> | getAnnotation(Class<A> annotationClass)                          | 该元素如果存在指定类型的注解，则返回这些注解，否则返回 null。                                                                                             |
| Annotation[]           | getAnnotations()                                                 | 返回此元素上存在的所有注解，包括从父类继承的                                                                                                              |
| boolean                | isAnnotationPresent(Class<? extends Annotation> annotationClass) | 如果指定类型的注解存在于此元素上，则返回true，否则返回 false。                                                                                            |
| Annotation[]           | getDeclaredAnnotations()                                         | 返回直接存在于此元素上的所有注解，注意，不包括父类的注解，调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响，没有则返回长度为0的数组 |
*** 案例
要解析的类如下
#+begin_src java
  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;
  import java.util.Map;
  @Target({ElementType.PACKAGE,
              ElementType.TYPE,
              ElementType.FIELD,
              ElementType.CONSTRUCTOR,
              ElementType.METHOD,
              ElementType.PARAMETER,
              ElementType.TYPE_PARAMETER,
              ElementType.TYPE_USE})
              @Retention(RetentionPolicy.RUNTIME)
              @interface Ann11 {
                  String value();
              }

  @Target({ElementType.PACKAGE,
              ElementType.TYPE,
              ElementType.FIELD,
              ElementType.CONSTRUCTOR,
              ElementType.METHOD,
              ElementType.PARAMETER,
              ElementType.TYPE_PARAMETER,
              ElementType.TYPE_USE})
              @Retention(RetentionPolicy.RUNTIME)
              @interface Ann11_0 {
                  int value();
              }

  @Ann11("用在了类上")
  @Ann11_0(0)
  public class UseAnnotation11<@Ann11("用在了类变量类型V1上") @Ann11_0(1) V1,@Ann11("用在了类变量类型V2上") @Ann11_0(2) V2> {
      @Ann11("用在了字段上")
      @Ann11_0(3)
      private String name;

      private Map<@Ann11("用在了泛型类型上,String") @Ann11_0(4) String, @Ann11("用在了泛型类型上,Integer") @Ann11_0(5) Integer> map;

      @Ann11("用在了构造方法上")
      @Ann11_0(6)
      public UseAnnotation11() {
          this.name = name;
      }

      @Ann11("用在了返回值上")
      @Ann11_0(7)
      public String m1(@Ann11("用在了参数上") @Ann11_0(8) String name) {
          return null;
      }
  }
#+end_src
**** 解析类上的注解
***** 解析这部分
#+begin_src java
  @Ann11("用在了类上")
#+end_src
***** 代码
#+begin_src java
  @Test
  public void m1() {
      for (Annotation annotation : UserAnnotation11.class.getAnnotations()) {
          System.out.println(annotation);
      }
  }
#+end_src
运行输出
#+begin_src java
  @com.demo18.Ann11(value=用在了类上)
  @com.demo18.Ann11_0(value=0)
#+end_src
**** 解析类上的类型变量
解析类名后面的尖括号的部分，即下面这部分
#+begin_src java
  UseAnnotation11<@Ann11("用在了类变量类型V1上") @Ann11_0(1) V1, @Ann11("用在了类变量类型V2上") @Ann11_0(2) V2>
#+end_src
用例代码：
#+begin_src java
  @Test
  public void m2() {
      TypeVariable<Class<UserAnnotation10>>[] typeParameters = UserAnnotation10.class.getTypeParameters();
      for (TypeVariable<Class<UserAnnotation10>> typeParameter : typeParameters) {
          System.out.println(typeParameter.getName() + "变量类型注解信息：");
          Annotation[] annotations = typeParameter.getAnnotations();
          for (Annotation annotation : annotations) {
              System.out.println(annotation);
          }
      }
  }
#+end_src
运行输出：
#+begin_src java
  V1变量类型注解信息：
  @com.demo18.Ann11(value=用在了类变量类型V1上)
  @com.demo18.Ann11_0(value=1)
  V2变量类型注解信息：
  @com.demo18.Ann11(value=用在了类变量类型V2上)
  @com.demo18.Ann11_0(value=2)
#+end_src
**** 解析字段name上的注解
用例代码：
#+begin_src java
  @Test
  public void m3() throws NoSuchFieldException {
      Field nameField = UserAnnotation11.class.getDeclaredField("name");
      for (Annotation annotation : nameField.getAnnotations()) {
          System.out.println(annotation);
      }
  }
#+end_src
运行输出
#+begin_src java
  @com.javacode2018.lesson001.demo18.Ann11(value=用在了字段上)
  @com.javacode2018.lesson001.demo18.Ann11_0(value=3)
#+end_src
**** 解析泛型字段map上的注解
用例代码：
#+begin_src java
  @Test
  public void m4() throws NoSuchFieldException, ClassNotFoundException {
      Field field = UseAnnotation11.class.getDeclaredField("map");
      Type genericType = field.getGenericType();
      Type[] actualTypeArguments = ((ParameterizedType)genericType).getActualTypeArguments();
      AnnotatedType annotatedType = field.getAnnotatedType();
      AnnotatedType[] annotatedActualTypeArguments = ((AnnotatedParameterizedType)annotatedType).getAnnotatedActualTypeArguments();
      int i = 0;
      for (AnnotatedType actualTypeArgument : annotatedActualTypeArguments) {
          Type actualTypeArgument1 = actualTypeArguments[i++];
          System.out.println(actualTypeArgument1.getTypeName() + "类型上的注解如下：");
          for (Annotation annotation : actualTypeArgument.getAnnotations()) {
              System.out.println(annotation);
          }
      }
  }
#+end_src
输出如下：
#+begin_src java
  java.lang.String类型上的注解如下：
  @com.javacode2018.lesson001.demo18.Ann11(value=用在了泛型类型上,String)
  @com.javacode2018.lesson001.demo18.Ann11_0(value=4)
  java.lang.Integer类型上的注解如下：
  @com.javacode2018.lesson001.demo18.Ann11(value=用在了泛型类型上,Integer)
  @com.javacode2018.lesson001.demo18.Ann11_0(value=5)
#+end_src

**** 解析构造函数上的注解
用例代码：
#+begin_src java
  @Test
  public void m5() {
      Constructor<?> constructor = UseAnnotation11.class.getConstructors()[0];
      for (Annotation annotation : constructor.getAnnotations()) {
          System.out.println(annotation);
      }
  }
#+end_src
运行输出：
#+begin_src java
  @com.javacode2018.lesson001.demo18.Ann11(value=用在了构造方法上)
  @com.javacode2018.lesson001.demo18.Ann11_0(value=6)
#+end_src



**** 解析m1方法上的注解
用例代码：
#+begin_src java
  @Test
  public void m6() throws NoSuchMethodException {
      Method method = UseAnnotation11.class.getMethod("m1", String.class);
      for (Annotation annotation : method.getAnnotations()) {
          System.out.println(annotation);
      }
  }
#+end_src
输出：
#+begin_src java
  @com.javacode2018.lesson001.demo18.Ann11(value=用在了返回值上)
  @com.javacode2018.lesson001.demo18.Ann11_0(value=7)
#+end_src


**** 解析m1方法参数注解
用例代码：
#+begin_src java
  @Test
  public void m7() throws NoSuchMethodException {
      Method method = UseAnnotation11.class.getMethod("m1", String.class);
      for (Parameter parameter : method.getParameters()) {
          System.out.println(String.format("参数%s上的注解如下:",parameter.getName()));
          for (Annotation annotation : parameter.getAnnotations()) {
              System.out.println(annotation);
          }
      }
  }
#+end_src
运行输出：
#+begin_src java
  参数arg0上的注解如下:
  @com.javacode2018.lesson001.demo18.Ann11(value=用在了参数上)
  @com.javacode2018.lesson001.demo18.Ann11_0(value=8)
#+end_src

** @Inherit: 实现类之间的注解继承
*** 用法
首先看一下源码
#+begin_src java
  @Documented
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.ANNOTATION_TYPE)
  public @interface Inherited {
  }
#+end_src
我们通过@Target元注解的属性可以看出，这个@Inherit是专门用来修饰注解的。
**** 作用
让子类可以继承父类中被 *@Inherit* 修饰的注解，注意是继承父类中的，如果接口中的注解也使用 *@Inherit* 修饰了，那么接口的实现类是无法继承这个注解的。
*** 案例
#+begin_src java
  import java.lang.annotation.*;
  public class InheritAnnotationTest {
      @Target(ElementType.TYPE)
      @Retention(RetentionPolicy.RUNTIME)
      @Inherited
      @interface A1{ //@1
      }
      @Target(ElementType.TYPE)
      @Retention(RetentionPolicy.RUNTIME)
      @Inherited
      @interface A2{ //@2
      }
      @A1 //@3
      interface I1{}
      @A2 //@4
      static class C1{}
      static class C2 extends C1 implements I1{} //@5
      public static void main(String[] args) {
          for (Annotation annotation : C2.class.getAnnotations()) { //@6
              System.out.println(annotation);
          }
      }
  }
#+end_src
@1：定义了一个注解A1，上面使用了@Inherited，表示这个具有继承功能

@2：定义了一个注解A2，上面使用了@Inherited，表示这个具有继承功能

@3：定义接口I1，上面使用了@A1注解

@4：定义了一个C1类，使用了A2注解

@5：C2继承了C1并且实现了I1接口

@6：获取C2上以及从父类继承过来的所有注解，然后输出
#+begin_src java
  @com.javacode2018.lesson001.demo18.InheritAnnotationTest$A2()
#+end_src
从输出中可以看出类可以继承父类上被@Inherit修饰的注解，而不能继承接口上被@Inherit修饰的注解，这个 *一定要要注意！！！！！！* 。

** @Repeatable重复使用注解
#+begin_src java
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.TYPE)
  @interface Ann12{}
  @Ann12
  @Ann12
  public class UseAnnotation12 {
  }
#+end_src
上面代码会报错，原因是：UseAnnotation12上面重复使用了@Ann12注解，默认情况下@Ann12注解是不允许重复使用的。

像上面这样，如果我们想重复使用注解的时候，需要用到 @Repeatable 注解
*** 使用步骤
**** 先定义容器注解
#+begin_src java
  @Retention(RetentionPolicy.RUNTIME)
  @Target({ElementType.TYPE, ElementType.FIELD})
  @interface Ann12s {
      Ann12[] value(); //@1
  }
#+end_src
容器注解中必须有个value类型的参数，参数类型为子注解类型的数组。
**** 为注解指定容器
要让一个注解可以反复使用，需要在注解上加上@Repeatable注解，@Repeatable中value的值为容器注解，如下代码中的@2
#+begin_src java
  @Retention(RetentionPolicy.RUNTIME)
  @Target({ElementType.TYPE, ElementType.FIELD})
  @Repeatable(Ann12s.class)//@2
  @interface Ann12 {
      String name();
  }
#+end_src
**** 使用注解
重复使用相同的注解有2种方式，如下面代码
1. 重复使用注解，如下面的类上重复使用@Ann12注解
2. 通过容器注解来使用更多个注解，如下面的字段v1上使用@Ann12s容器注解
#+begin_src java
  @Ann12(name = "Java")
  @Ann12(name = "Spring")
  public class UseAnnotation12 {
      @Ann12s({@Ann12(name = "Java高并发"),@Ann12(name = "mysql高手")})
      private String v1;
  }
#+end_src
**** 获取注解信息
#+begin_src java
  @Test
  public void test1() throws NoSuchFieldException {
      Annotation[] annotations = UseAnnotation12.class.getAnnotations();
      for (Annotation annotation : annotations) {
          System.out.println(annotation);
      }
      System.out.println("-------------");
      Field v1 = UseAnnotation12.class.getDeclaredField("v1");
      Annotation[] declaredAnnotations = v1.getDeclaredAnnotations();
      for (Annotation declaredAnnotation : declaredAnnotations) {
          System.out.println(declaredAnnotation);
      }
  }
#+end_src
运行输出：
#+begin_src java
  @com.javacode2018.lesson001.demo18.Ann12s(value=[@com.javacode2018.lesson001.demo18.Ann12(name=Java),@com.javacode2018.lesson001.demo18.Ann12(name=Spring系列)])
  -------------
  @com.javacode2018.lesson001.demo18.Ann12s(value=[@com.javacode2018.lesson001.demo18.Ann12(name=Java高并发系列),@com.javacode2018.lesson001.demo18.Ann12(name=mysql高手系列)])
#+end_src

** ==以上是Java中对注解的支持，下面是spring中对于注解方面的支持==
** Spring中对于注解方面的支持
*** 先瞅一个问题
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface A1 {
      String value() default "a";//@0
  }
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @A1
  @interface B1 { //@1
      String value() default "b";//@2
  }
  @B1("Java") //@3
  public class UseAnnotation13 {
      @Test
      public void test1() {
          //AnnotatedElementUtils是spring提供的一个查找注解的工具类
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation13.class, B1.class));
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation13.class, A1.class));
      }
  }
#+end_src
@0：A1注解value参数值默认为a

@1：B1注解上使用到了@A1注解

@2：B1注解value参数值默认为b

@2：UseAnnotation13上面使用了@B1注解，value参数的值为：java

test1方法中使用到了spring中的一个类 AnnotatedElementUtils ，通过这个工具类可以很方便的获取注解的各种信息，方法中的2行代码用于获取UseAnnotation13类上B1注解和A1注解的信息。

输出结果如下：
#+begin_src java
  @com.javacode2018.lesson001.demo18.B1(value=Java)
  @com.javacode2018.lesson001.demo18.A1(value=a)
#+end_src
此时有个问题：此时如果想在 UseAnnotation13 上给B1上的A1注解设置值是没有办法的，注解定义无法继承导致的，如果注解定义上面能够继承，那用起来会爽很多，spring通过@Aliasfor方法解决了这个问题。
*** Spring @AliasFor: 对注解进行增强
**** 案例1 通过 @AliasFor 解决刚才的难题
#+begin_src java
  import org.junit.Test;
  import org.springframework.core.annotation.AliasFor;
  import org.springframework.core.annotation.AnnotatedElementUtils;
  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface A14 {
      String value() default "a";//@0
  }
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @A14 //@6
  @interface B14 { //@1
      String value() default "b";//@2
      @AliasFor(annotation = A14.class, value = "value") //@5
      String a14Value();
  }
  @B14(value = "Java",a14Value = "通过B14给A14的value参数赋值") //@3
  public class UseAnnotation14 {
      @Test
      public void test1() {
          //AnnotatedElementUtils是spring提供的一个查找注解的工具类
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation14.class, B14.class));
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation14.class, A14.class));
      }
  }
#+end_src
运行输出：
#+begin_src java
  @com.javacode2018.lesson001.demo18.B14(a14Value=通过B14给A14的value参数赋值, value=Java)
  @com.javacode2018.lesson001.demo18.A14(value=通过B14给A14的value参数赋值)
#+end_src
这个相当于给某个注解指定别名，即将B1注解中 a14Value 参数作为 A14 中 value 参数的别名，当给B1的a14Value 设置值的时候，就相当于给 A14的value设置值 ，有个前提是@AliasFor注解的annotation 参数指定的注解需要加载当前注解上面，如：@6
**** 案例2 同一个注解中使用@AliasFor
#+begin_src java
  import org.junit.Test;
  import org.springframework.core.annotation.AliasFor;
  import org.springframework.core.annotation.AnnotatedElementUtils;
  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;
  @Target({ElementType.TYPE, ElementType.FIELD})
  @Retention(RetentionPolicy.RUNTIME)
  @interface A15 {
      @AliasFor("v2")//@1
      String v1() default "";
      @AliasFor("v1")//@2
      String v2() default "";
  }
  @A15(v1 = "我是v1") //@3
  public class UseAnnotation15 {
      @A15(v2 = "我是v2") //@4
      private String name;
      @Test
      public void test1() throws NoSuchFieldException {
          //AnnotatedElementUtils是spring提供的一个查找注解的工具类
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation15.class, A15.class));
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation15.class.getDeclaredField("name"), A15.class));
      }
  }
#+end_src
注意上面代码，A15注解中（@1和@2）的2个参数都设置了@AliasFor，@AliasFor如果不指定annotation 参数的值，那么 annotation 默认值就是当前注解，所以上面2个属性互为别名，当
给v1设置值的时候也相当于给v2设置值，当给v2设置值的时候也相当于给v1设置值。

运行输出：
#+begin_src java
  @com.javacode2018.lesson001.demo18.A15(v1=我是v1, v2=我是v1)
  @com.javacode2018.lesson001.demo18.A15(v1=我是v2, v2=我是v2)
#+end_src
从输出中可以看出v1和v2的值始终是相等的，上面如果同时给v1和v2设置值的时候运行代码会报错。

回头来看看@AliasFor的源码:
#+begin_src java
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.METHOD)
  @Documented
  public @interface AliasFor {
      @AliasFor("attribute")
      String value() default "";
      @AliasFor("value")
      String attribute() default "";
      Class<? extends Annotation> annotation() default Annotation.class;
  }
#+end_src
AliasFor注解中 value 和 attribute 互为别名，随便设置一个，同时会给另外一个设置相同的值。


**** 案例3 @AliasFor中不指定value和attribute
当@AliasFor中不指定value或者attribute的时候，自动将@AliasFor修饰的参数作为value和attribute的值，如下@AliasFor注解的value参数值为name
#+begin_src java
  import org.junit.Test;
  import org.springframework.core.annotation.AliasFor;
  import org.springframework.core.annotation.AnnotatedElementUtils;
  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @interface A16 {
      String name() default "a";//@0
  }
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @A16
  @interface B16 { //@1
      @AliasFor(annotation = A16.class) //@5
      String name() default "b";//@2
  }
  @B16(name="我是v1") //@3
  public class UseAnnotation16 {
      @Test
      public void test1() throws NoSuchFieldException {
          //AnnotatedElementUtils是spring提供的一个查找注解的工具类
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation16.class, A16.class));
          System.out.println(AnnotatedElementUtils.getMergedAnnotation(UseAnnotation16.class, B16.class));
      }
  }
#+end_src
运行输出：
#+begin_src java
  @com.javacode2018.lesson001.demo18.A16(name=我是v1)
  @com.javacode2018.lesson001.demo18.B16(name=我是v1)
#+end_src

* @Configration和@Bean注解
** 前言
之前我们都是通过xml的方式定义bean，里面会写很多bean元素，然后spring启动的时候，就会读取bean xml配置文件，然后解析这些配置，然后会将这些bean注册到spring容器中，供使用者使用。
jdk1.5里面有了注解的功能，spring也没闲着，觉得注解挺好用的，就将注解加了进来，让我们通过注解的方式来定义bean，用起来能达到xml中定义bean一样的效果，并且更简洁一些，这里面需要用到的
注解就有 @Configuration 注解和 @Bean 注解。
** @Configration注解
*** 用法
@Configuration这个注解可以加在类上，让这个类的功能等同于一个bean xml配置文件，如下：
#+begin_src java
  @Configuration
  public class ConfigBean {
  }
#+end_src
上面代码类似于xml
#+begin_src xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">
  </beans>
#+end_src
通过 AnnotationConfigApplicationContext 来加载 @Configuration 修饰的类，如下：
#+begin_src java
  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConfigBean.class);
#+end_src
此时ConfigBean类中没有任何内容，相当于一个空的xml配置文件，此时我们要在ConfigBean类中注册bean，那么我们就要用到@Bean注解了。
*** 总结 @Configuration 使用步骤：
1. 在类上使用 @Configuration 注解
2. 通过 AnnotationConfigApplicationContext 容器来加 @Configuration 注解修饰的类

** @Bean注解
*** 用法
这个注解类似于bean xml配置文件中的bean元素，用来在spring容器中注册一个bean。@Bean注解用在方法上，表示通过方法来定义一个bean，默认将方法名称作为bean名称，将方法返回值作为bean对象，注册到spring容器中。
#+begin_src java
  @Bean
  public User user1() {
      return new User();
  }
#+end_src
@Bean注解还有很多属性，我们来看一下其源码：
#+begin_src java
  @Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE}) //@1
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  public @interface Bean {
      @AliasFor("name")
      String[] value() default {};
      @AliasFor("value")
      String[] name() default {};
      @Deprecated
      Autowire autowire() default Autowire.NO;
      boolean autowireCandidate() default true;
      String initMethod() default "";
      String destroyMethod() default AbstractBeanDefinition.INFER_METHOD;
  }
#+end_src
@1：说明这个注解可以用在方法和注解类型上面。

每个参数含义：
  1. value和name是一样的，设置的时候，这2个参数只能选一个，原因是@AliasFor导致的@AliasFor这个注解不清楚的可以看这个文章：详解注解
  2. value：字符串数组，第一个值作为bean的名称，其他值作为bean的别名
  3. autowire：这个参数上面标注了@Deprecated，表示已经过期了，不建议使用了
  4. autowireCandidate：是否作为其他对象注入时候的候选bean，之前的文章中专门介绍过这个属性，不清楚的可以去看看：autowire-candidate详解
  5. initMethod：bean初始化的方法，这个和生命周期有关，后面详解
  6. destroyMethod：bean销毁的方法，也是和生命周期相关的，后面详解

*** 案例
User类
#+begin_src java
  public class User {
  }
#+end_src
Bean配置类：ConfigBean
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  public class ConfigBean {
      //bean名称为方法默认值：user1
      @Bean
      public User user1() {
          return new User();
      }
      //bean名称通过value指定了：user2Bean
      @Bean("user2Bean")
      public User user2() {
          return new User();
      }
      //bean名称为：user3Bean，2个别名：[user3BeanAlias1,user3BeanAlias2]
      @Bean({"user3Bean", "user3BeanAlias1", "user3BeanAlias2"})
      public User user3() {
          return new User();
      }
  }
#+end_src
测试类
#+begin_src java
  import org.junit.Test;
  import org.springframework.context.annotation.AnnotationConfigApplicationContext;
  import java.util.Arrays;
  public class ConfigurationTest {
      @Test
      public void test1() {
          AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConfigBean.class);//@1
          for (String beanName : context.getBeanDefinitionNames()) {
              //别名
              String[] aliases = context.getAliases(beanName);
              System.out.println(String.format("bean名称:%s,别名:%s,bean对象:%s",beanName,Arrays.asList(aliases),context.getBean(beanName)));
          }
      }
  }
#+end_src
@1：通过 AnnotationConfigApplicationContext 来加载配置类 ConfigBean ，会将配置类中所有的bean注册到spring容器中

for循环中输出了bean名称、别名、bean对象

输出如下：
#+begin_src java
  bean名称:org.springframework.context.annotation.internalConfigurationAnnotationProcessor,别名:[],bean对象:org.springframework.context.annotation.ConfigurationClassPostProcessor@3bd82cf5
  bean名称:org.springframework.context.annotation.internalAutowiredAnnotationProcessor,别名:[],bean对象:org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@544fa968
  bean名称:org.springframework.context.annotation.internalCommonAnnotationProcessor,别名:[],bean对象:org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@247bddad
  bean名称:org.springframework.context.event.internalEventListenerProcessor,别名:[],bean对象:org.springframework.context.event.EventListenerMethodProcessor@d35dea7
  bean名称:org.springframework.context.event.internalEventListenerFactory,别名:[],bean对象:org.springframework.context.event.DefaultEventListenerFactory@7770f470
  bean名称:configBean,别名:[],bean对象:com.javacode2018.lesson001.demo20.ConfigBean$$EnhancerBySpringCGLIB$$dde45976@5e5d171f
  bean名称:user1,别名:[],bean对象:com.javacode2018.lesson001.demo20.User@24313fcc
  bean名称:user2Bean,别名:[],bean对象:com.javacode2018.lesson001.demo20.User@7d20d0b
  bean名称:user3Bean,别名:[user3BeanAlias2, user3BeanAlias1],bean对象:com.javacode2018.lesson001.demo20.User@77f1baf5
#+end_src
从输出中可以看出，有个名称为 configBean 的bean，正是ConfigBean这个类型，可以得出，被@Configuration修饰的类，也被注册到spring容器中了最后3行输出就是几个User的bean对象了。

** @Configuration加不加到底区别在哪里呢
通常情况下bean和bean之间是有依赖关系的。

被@Configuration修饰的类，spring容器中会通过cglib给这个类创建一个代理，代理会拦截所有被@Bean修饰的方法，默认情况(bean为单例)下确保这些方法只被调用一次，从而
确保这些bean是同一个bean，即单例的。

* @ComponentScan,@ComponentScans详解
** 灵魂拷问
1. @ComponetsScan注解是做什么的？
2. basePackages的方式和basePackageClasses的方式有什么区别？你建议用哪个？为什么？
3. useDefaultFilters有什么用？
4. 常见的过滤器有哪些？
5. @ComponetsScan是在哪个类中处理的
** 背景介绍
目前为止我们知道了两种注册bean的方式
1. xml中bean元素的方式
2. @Bean注解标注方法的方式

通常情况下 ，项目中大部分类都需要交给spring去管理，按照上面这两种方式，代码量还是挺大的，为了更方便bean的注册，spring提供了
批量的方式注册bean,方便大量bean批量注册，spring中的@ComponentScan就是干这个事情的。
** @ComponentScan
@ComponentScan用于批量注册bean。

这个注解会让spring去扫描某些包及其子包中所有的类，然后将满足一定条件的类作为bean注册到spring容器容器中。

具体需要扫描哪些包？以及这些包中的类满足什么条件时被注册到容器中，这些都可以通过这个注解中的参数动态配置。

*** 注解的定义
#+begin_src java
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.TYPE)
  @Documented
  @Repeatable(ComponentScans.class) //@1
  public @interface ComponentScan {
      @AliasFor("basePackages")
      String[] value() default {};
      @AliasFor("value")
      String[] basePackages() default {};
      Class<?>[] basePackageClasses() default {};
      Class<? extends BeanNameGenerator> nameGenerator() default
          BeanNameGenerator.class;
      Class<? extends ScopeMetadataResolver> scopeResolver() default
          AnnotationScopeMetadataResolver.class;
      ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;
      String resourcePattern() default "**/*.class";
      boolean useDefaultFilters() default true;
      Filter[] includeFilters() default {};
      Filter[] excludeFilters() default {};
      boolean lazyInit() default false;
  }
#+end_src
定义上可以看出此注解可以用在任何类型上面，不过我们通常将其用在类上面。

常用参数：
#+begin_src doc

value：指定需要扫描的包，如：com.javacode2018

basePackages：作用同value；value和basePackages不能同时存在设置，可二选一

basePackageClasses：指定一些类，spring容器会扫描这些类所在的包及其子包中的类

nameGenerator：自定义bean名称生成器

resourcePattern：需要扫描包中的那些资源，默认是：**/*.class，即会扫描指定包中所有的class文件

useDefaultFilters：对扫描的类是否启用默认过滤器，默认为true

includeFilters：过滤器：用来配置被扫描出来的那些类会被作为组件注册到容器中

excludeFilters：过滤器，和includeFilters作用刚好相反，用来对扫描的类进行排除的，被排除的类不会被注册到容器中

lazyInit：是否延迟初始化被注册的bean

@1：@Repeatable(ComponentScans.class)，这个注解可以同时使用多个。

#+end_src
@ComponentScan工作的过程：
1. Spring会扫描指定的包，且会递归下面子包，得到一批类的数组
2. 然后这些类会经过上面的各种过滤器，最后剩下的类会被注册到容器中

第一：需要扫描哪些包？通过 value、backPackages、basePackageClasses 这3个参数来控制

第二：过滤器有哪些？通过 useDefaultFilters、includeFilters、excludeFilters 这3个参数来控制过滤器

默认情况下，任何参数都不设置的情况下，此时，会将@ComponentScan修饰的类所在的包作为扫描包；默认情况下useDefaultFilters为true，
这个为true的时候，spring容器内部会使用默认过滤器，规则是：凡是类上有 @Repository、@Service、@Controller、@Component 这几个注解中的任何一
个的，那么这个类就会被作为bean注册到spring容器中，所以默认情况下，只需在类上加上这几个注解中的任何一个，这些类就会自动交给spring容器来管理了。

** @Component,@Repository,@Service,@Controller
这几个注解都是spring提供的。

*** @Component注解
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  @Indexed
  public @interface Component {
      String value() default "";
  }
#+end_src
从定义中可以看出，这个注解可以用在任何类型上面。通常情况下将这个注解用在类上面，标注这个类为一个组件，
默认情况下，被扫描的时候会被作为bean注册到容器中。value参数：被注册为bean的时候，用来指定bean的名称，如果不指定，
默认为类名首字母小写。如：类UserService对应的beanname为userService
*** @Repository注解
#+begin_src java
  @Target({ElementType.TYPE})
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  @Component
  public @interface Repository {
      @AliasFor(annotation = Component.class)
      String value() default "";
  }
#+end_src
Repository上面有@Component注解。value参数上面有 @AliasFor(annotation = Component.class) ，
设置value参数的时候，也相当于给 @Component 注解中的value设置值。
*** @Service和@Controller注解源码和@Respository源码类似
*** 总结
这4个注解本质上是没有任何差别，都可以用在类上面，表示这个类被spring容器扫描的时候，可以作为一个bean组件注册到spring容器中。
spring容器中对这4个注解的解析并没有进行区分，统一采用 @Component 注解的方式进行解析，所以这几个注解之间可以相互替换。
spring提供这4个注解，是为了让系统更清晰，通常情况下，系统是分层结构的，多数系统一般分为controller层、service层、dao层。
@controller通常用来标注controller层组件，@service注解标注service层的组件，@Repository标注dao层的组件，
这样可以让整个系统的结构更清晰，当看到这些注解的时候，会和清晰的知道属于哪个层，对于spring来说，
将这3个注解替换成@Component注解，对系统没有任何影响，产生的效果是一样的。

** 案例
*** 案例1：任何参数未设置
UserController.java
#+begin_src java
  import org.springframework.stereotype.Controller;
  @Controller
  public class UserController {
  }
#+end_src
UserService.java
#+begin_src java
  import org.springframework.stereotype.Service;
  @Service
  public class UserService {
  }
#+end_src
UserDao.java
#+begin_src java
  import org.springframework.stereotype.Repository;
  @Repository
  public class UserDao {
  }
#+end_src
UserModel.java
#+begin_src java
  @Component
  public class UserModel {
  }
#+end_src
上面几个类中，分别使用了4种注解

@ComponentScan修饰的类(最外层)
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  @ComponentScan
  public class ScanBean1 {
  }
#+end_src
测试用例
#+begin_src java
  import com.javacode2018.lesson001.demo22.test1.ScanBean1;
  import org.junit.Test;
  import org.springframework.context.annotation.AnnotationConfigApplicationContext;
  public class ComponentScanTest {
      @Test
      public void test1() {
          AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ScanBean1.class);
          for (String beanName : context.getBeanDefinitionNames()) {
              System.out.println(beanName + "->" + context.getBean(beanName));
          }
      }
  }
#+end_src
@1：使用AnnotationConfigApplicationContext作为ioc容器，将 ScanBean 作为参数传入。

默认会扫描 ScanBean 类所在的包中的所有类，类上有@Component、@Repository、@Service、@Controller任何一个注解的都会被注册到容器中

*** 案例2： 指定需要扫描的包
指定需要扫描哪些包，可以通过value或者basePackage来配置，二者选其一，都配置运行会报错，下面我们通过value来配置。

ScanBean2.java
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  @ComponentScan({"com.demo22.test1.controller","com.demo22.test1.service"})
  public class ScanBean2 {
  }
#+end_src
上面指定了2需要扫描的包，这两个包中有2个类。

**** 测试用例
ComponentScanTest中新增两个方法
#+begin_src java
  @Test
  public void test2() {
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ScanBean2.class);
      for (String beanName : context.getBeanDefinitionNames()) {
          System.out.println(beanName + "->" + context.getBean(beanName));
      }
  }
#+end_src
**** 运行输出
可以看出只有controller包和service包中的2个类被注册为bean了。
**** 注意
指定包名的方式扫描存在的一个隐患，若包被重名了，会导致扫描会失效，一般情况下面我们使用basePackageClasses的方式来指定需要扫描的包，这个参数
可以指定一些类型，默认会扫描这些类所在的包及其子包中所有的类，这种方式可以有效避免这种问题。
*** 案例3：basePackageClasses指定扫描范围
我们可以在需要扫描的包中定义一个标记的接口或者类，他们的唯一的作用是作为basePackageClasses的值，其他没有任何用途。

定义接口
#+begin_src java
  public interface ScanClass {
  }
#+end_src
定义两个类
#+begin_src java
  import org.springframework.stereotype.Component;
  @Component
  public class Service1 {
  }



  import org.springframework.stereotype.Component;
  @Component
  public class Service2 {
  }
#+end_src
@ComponentScan标记的类
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  @ComponentScan(basePackageClasses = ScanClass.class)
  public class ScanBean6 {
  }
#+end_src
测试用例
#+begin_src java
  @Test
  public void test6() {
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ScanBean6.class);
      for (String beanName : context.getBeanDefinitionNames()) {
          System.out.println(beanName + "->" + context.getBean(beanName));
      }
  }
#+end_src
运行输出
#+begin_src java
  service1->com.javacode2018.lesson001.demo22.test6.beans.Service1@79924b
  service2->com.javacode2018.lesson001.demo22.test6.beans.Service2@7b9a4292
#+end_src

** includeFilters的使用
*** 用法
includeFilters参数的定义：
#+begin_src java
  Filter[] includeFilters() default {};
#+end_src
是一个 Filter 类型的数组，多个Filter之间为或者关系，即满足任意一个就可以了，看一下 Filter 的代码：
#+begin_src java
  @Retention(RetentionPolicy.RUNTIME)
  @Target({})
  @interface Filter {
      FilterType type() default FilterType.ANNOTATION;
      @AliasFor("classes")
      Class<?>[] value() default {};
      @AliasFor("value")
      Class<?>[] classes() default {};
      String[] pattern() default {};  }

#+end_src
可以看出Filter也是一个注解，参数：

type：过滤器的类型，是个枚举类型，5种类型

ANNOTATION：通过注解的方式来筛选候选者，即判断候选者是否有指定的注解

ASSIGNABLE_TYPE：通过指定的类型来筛选候选者，即判断候选者是否是指定的类型

ASPECTJ：ASPECTJ表达式方式，即判断候选者是否匹配ASPECTJ表达式

REGEX：正则表达式方式，即判断候选者的完整名称是否和正则表达式匹配

CUSTOM：用户自定义过滤器来筛选候选者，对候选者的筛选交给用户自己来判断

value：和参数classes效果一样，二选一

classes：3种情况如下

当type=FilterType.ANNOTATION时，通过classes参数可以指定一些注解，用来判断被扫描的类上是否有classes参数指定的注解

当type=FilterType.ASSIGNABLE_TYPE时，通过classes参数可以指定一些类型，用来判断被扫描的类是否是classes参数指定的类型

当type=FilterType.CUSTOM时，表示这个过滤器是用户自定义的，classes参数就是用来指定用户自定义的过滤器，自定义的过滤器需要实现org.springframework.core.type.filter.TypeFilter接口

pattern：2种情况如下

当type=FilterType.ASPECTJ时，通过pattern来指定需要匹配的ASPECTJ表达式的值

当type=FilterType.REGEX时，通过pattern来自正则表达式的值

*** 案例：扫描包含注解的类
**** 需求
我们自定义一个注解，让标注有这些注解的类自动注册到容器中
**** 代码实现

定义一个注解
#+begin_src java
  import java.lang.annotation.*;
  @Documented
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface MyBean {
  }
#+end_src
创建一个类，使用这个注解标注
#+begin_src java
  @MyBean
  public class Service1 {
  }
#+end_src
再来一个类，使用spring中的 @Compontent 标注
#+begin_src java
  import org.springframework.stereotype.Component;
  @Component
  public class Service2 {
  }

#+end_src
再来一个类，使用@CompontentScan标注
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  import org.springframework.context.annotation.FilterType;
  @ComponentScan(includeFilters = {
          @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = MyBean.class)
  })
  public class ScanBean3 {
  }
#+end_src
上面指定了Filter的type为注解的类型，只要类上面有 @MyBean 注解的，都会被作为bean注册到容器中

**** 扩展：自定义注解支持定义bean名称
上面的自定义的@MyBean注解，是无法指定bean的名称的，可以对这个注解做一下改造，加个value参
数来指定bean的名称，如下：
#+begin_src java
  @Documented
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @Component //@1
  public @interface MyBean {
      @AliasFor(annotation = Component.class) //@2
      String value() default ""; //@3
  }
#+end_src
重点在于@1和@2这2个地方的代码，通过上面的参数可以间接给@Component注解中的value设
置值。这块用到了@AliasFor注解，

**** 自定义Filter案例
***** 需求
我们来个自定义的Filter，判断被扫描的类如果是 IService 接口类型的，就让其注册到容器中。
***** 代码实现
来个自定义的TypeFilter类
#+begin_src java
  import com.javacode2018.lesson001.demo22.test4.IService;
  import org.springframework.core.type.ClassMetadata;
  import org.springframework.core.type.classreading.MetadataReader;
  import org.springframework.core.type.classreading.MetadataReaderFactory;
  import org.springframework.core.type.filter.TypeFilter;
  import java.io.IOException;
  public class MyFilter implements TypeFilter {
      /**
       ,*@param metadataReader
       ,*@param metadataReaderFactory
       ,*@return
       ,*@throws IOException
       ,*/
      @Override
      public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {
          Class curClass = null;
          try {
              //当前被扫描的类
              curClass = Class.forName(metadataReader.getClassMetadata().getClassName());
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          }
          //判断curClass是否是IService类型
          boolean result = IService.class.isAssignableFrom(curClass);
          return result;
      }
  }

#+end_src
来个@ComponetScan标注的类
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  import org.springframework.context.annotation.FilterType;
  @ComponentScan(basePackages = {"com.demo22.test4"},useDefaultFilters = false, //不启用默认过滤器
                 includeFilters = {@ComponentScan.Filter(type = FilterType.CUSTOM, classes =MyFilter.class) //@1 })
  public class ScanBean5 {
  }

#+end_src
@1：type为FilterType.CUSTOM，表示Filter是用户自定义的，classes为自定义的过滤器

**** excludeFilters
配置排除的过滤器，满足这些过滤器的类不会被注册到容器中
**** @ComponentScan重复使用
从这个注解的定义上可以看出这个注解可以同时使用多个
#+begin_src java
  @ComponentScan(basePackageClasses = ScanClass.class)
  @ComponentScan(
                 useDefaultFilters = false, //不启用默认过滤器
                 includeFilters = {
                     @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes=IService.class)
                 })
  public class ScanBean7 {
  }
#+end_src
还有一种写法
#+begin_src java
  @ComponentScans({
          @ComponentScan(basePackageClasses = ScanClass.class),
          @ComponentScan(
                         useDefaultFilters = false, //不启用默认过滤器
                         includeFilters = {@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,classes = IService.class)})})
  public class ScanBean7 {
  }
#+end_src

**** spring中这一块的源码
@ComponetScan注解是被下面这个类处理的
#+begin_src java
  org.springframework.context.annotation.ConfigurationClassPostProcessor
#+end_src
这个类非常非常关键，主要用户bean的注册，前面我们介绍的@Configuration,@Bean注解也是被这个类处理的。

还有下面这些注解
#+begin_src java
  @PropertySource
  @Import
  @ImportResource
  @Compontent
#+end_src
以上这些注解都是被ConfigurationClassPostProcessor这个类处理的，内部会递归处理这些注解，完成bean的注册。

以@CompontentScan来说一下过程，第一次扫描之后会得到一批需要注册的类，然后会对这些需要注册的类进行遍历，判断是否有上面任意一个注解，如果有，会将这个类交给
ConfigurationClassPostProcessor继续处理，直到递归完成所有bean的注册。

*想成为高手，这个类是必看的。*

** 总结
1. @ComponentScan用于批量注册bean，spring会按照这个注解的配置，递归扫描指定包中的所有类，将满足条件的类批量注册到spring容器中
2. 可以通过value、basePackages、basePackageClasses 这几个参数来配置包的扫描范围
3. 可以通过useDefaultFilters、includeFilters、excludeFilters这几个参数来配置类的过滤器，被过滤器处理之后剩下的类会被注册到容器中
4. 指定包名的方式配置扫描范围存在隐患，包名被重命名之后，会导致扫描实现，所以一般我们在需要扫描的包中可以创建一个标记的接口或者类，作为basePackageClasses的值，通过这个来控制包的扫描范围
5. @CompontScan注解会被ConfigurationClassPostProcessor类递归处理，最终得到所有需要注册的类。

* @Import批量注册bean
** @import出现背景
目前为止，注解的方式批量注册bean，介绍了两种

1. @Configuration结合@Bean注解的方式
2. @ComponentScan扫描包的方式
** 问题1
如果需要注册的类是在第三方的jar中，那么我们如果想注册这些bean有两种方式
1. 通过@Bean注解的方式，一个个来注册
2. @ComponentScan的方式：默认的@ComponentScan是无能为力的，默认情况下智慧注册@Component标注的类，此时智能自定义@ComponetScan中的过滤器了

这两种方式，每次有变化时，调整的代码比较多

** 问题2
通常我们的项目中有很多子模块，可能每个模块都是独立开发的，然后通过jar的方式引进来，每个模块都有各自的@Configuration @Bean标注的类，
或者使用@ComponentScan标注的类，被 *@Configuration,@Bean,@ComponentScan标注的类，我们统称为bean配置类，配置类可以用来注册bean* 当我们
只想使用其中几个模块的配置类，如何施行呢？

@Import可以很好的解决这两个问题

** @Import使用
先看Spring对他的注释，总结下来的作用就是和xml配置的<import/>标签作用一样，允许通过它引入@Configuration标注的类，引入ImportSelector接口和
ImportBeanDefinitionRegister接口的实现，也包括@Component注解的普通类。

总的来说：@Import可以用来批量导入需要注册的各种类，如普通的类，配置类，之后完成普通类和配置类中所有bean的注册。

@Import源码
#+begin_src java
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  public @interface Import {
      /**
       ,*{@link Configuration @Configuration}, {@link ImportSelector},
       ,*{@link ImportBeanDefinitionRegistrar}, or regular component classes toimport.
       ,*/
      Class<?>[] value();
  }
#+end_src

@Import可以使用在任何类型上，通常情况下，类和注解上用的比较多。

value: 一个Class数组，设置需要导入的类，可以是@Configuration标注的列，可以是ImportSelector接口或者ImportBeanDefinitionRegister接口类型的，
或者需要导入的普通组件得类。

*** 使用步骤
1. 将@Import标注在类上，设置value参数
2. 将@Import标注的类作为AnnotationConfigApplicationContext构造参数创建AnnotationConfigApplicationContext对象
3. 使用AnnotationConfigApplicationContext对象
*** @Import的value常见的有五种用法
1. value为普通的类
2. value为@Configuration标注的类
3. value为@CompontentScan标注的类
4. value为ImportBeanDefinitionRegistrar接口类型
5. value为ImportSelector接口类型
6. value为DeferredImportSelector接口类型
**** value为普通类
#+begin_src java
  public class Service1 {}
  public class Service2 {}
#+end_src
总配置类：使用@Import标注
#+begin_src java
  import org.springframework.context.annotation.Import;
  @Import({Service1.class, Service2.class})
  public class MainConfig {}
#+end_src
@Import 中导入了两个普通类：service1和service2，这两个类会被自动注册到容器中
**** value为@Configuration标注的配置类
项目比较大的情况下，会按照模块独立开发，每个模块在maven中就表现为一个个的构建，然后通过坐标的方式进行引入需要的模块

加入项目中有两个模块，两个模块都有各自的配置类，如下

模块1配置类
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  /**
   ,*模块1配置类
   ,*/
  @Configuration
  public class ConfigModule1 {
      @Bean
      public String module1() {
          return "我是模块1配置类！";
      }
  }
#+end_src
模块2配置类
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  /**
   ,*模块2配置类
  ,*/
  @Configuration
  public class ConfigModule2 {
      @Bean
      public String module2() {
          return "我是模块2配置类！";
      }
  }
#+end_src
总配置类：通过@Import导入两个模块的配置类
#+begin_src java
  import org.springframework.context.annotation.Import;
  @Import({ConfigModule1.class, ConfigModule2.class}) //@1
  public class MainConfig2{}
#+end_src
@1导入了2个模块中的模块配置类，可以按需导入。
**** value为@ComponentScan标注的类
项目中分多个模块，每个模块有各自独立的包，我们在每个模块所在的包中配置一个
@CompontentScan类，然后通过@Import来导入需要启用的模块。

***** 定义模块1:
包为：com.test.module1

组件1：Module1Service1
#+begin_src java
  import org.springframework.stereotype.Component;
  @Component
  public class Module1Service1 {}
#+end_src
组件2：Module1Service2
#+begin_src java
  import org.springframework.stereotype.Component;
  @Component
  public class Module1Service2 {
  }
#+end_src
组件扫描类：CompontentScanModule1------>负责扫描当前模块中的组件
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  import org.springframework.stereotype.Component;
  /**
     模块1的主键扫描
  ,*/
  @ComponentScan
  public class CompontentScanModule1 {
  }
#+end_src

***** 定义模块2:
包为：com.test.module2

组件1：Module2Service1
#+begin_src java
  import org.springframework.stereotype.Component;
  @Component
  public class Module2Service1 {}
#+end_src
组件2：Module2Service2
#+begin_src java
  import org.springframework.stereotype.Component;
  @Component
  public class Module2Service2 {
  }
#+end_src
组件扫描类：CompontentScanModule1------>负责扫描当前模块中的组件
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  import org.springframework.stereotype.Component;
  /**
     模块1的主键扫描
  ,*/
  @ComponentScan
  public class CompontentScanModule2 {
  }
#+end_src

***** 总配置类：通过@Import导入每个模块中的组件扫描类
#+begin_src java
  import org.springframework.context.annotation.Import;
  /**
   ,*通过@Import导入多个@CompontentScan标注的配置类
  ,*/
  @Import({CompontentScanModule1.class, CompontentScanModule2.class}) //@1
  public class MainConfig3 {
  }
#+end_src

**** 先了解一下几个相关的接口
***** ImportBeanDefinitionRegistrar接口
这个接口提供了通过spring容器api的方式直接向容器中注册bean

接口的完整名称：
#+begin_src java
  org.springframework.context.annotation.ImportBeanDefinitionRegistrar
#+end_src
源码：
#+begin_src java
  public interface ImportBeanDefinitionRegistrar {
      default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,BeanNameGenerator importBeanNameGenerator) {
          registerBeanDefinitions(importingClassMetadata, registry);
      }
      default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
      }
  }
#+end_src
两个默认方法，都可以用来调用spring容器api来注册bean

2个方法中主要有3个参数

importingClassMetadata：AnnotationMetadata类型的，通过这个可以获取被@Import注解标注的类所有注解的信息。

registry：BeanDefinitionRegistry类型，是一个接口，内部提供了注册bean的各种方法。

importBeanNameGenerator：BeanNameGenerator类型，是一个接口，内部有一个方法，用来生成bean的名称。

关于BeanDefinitionRegistry和BeanNameGenerator接口在来细说一下。
***** BeanDefinitionRegistry接口：bean定义注册器
bean定义注册器，提供了bean注册的各种办法，来看一下源码
#+begin_src java
  public interface BeanDefinitionRegistry extends AliasRegistry {
  /**
  ,*注册一个新的bean定义
  ,*beanName：bean的名称
  ,*beanDefinition：bean定义信息
  ,*/
  void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)throws BeanDefinitionStoreException;
  /**
  ,*通过bean名称移除已注册的bean
   beanName：bean名称
  ,*/
  void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;
  /**
  ,*通过名称获取bean的定义信息
  ,*beanName：bean名称
  ,*/
  BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;
  /**
  ,*查看beanName是否注册过
  ,*/
  boolean containsBeanDefinition(String beanName);
  /**
  ,*获取已经定义（注册）的bean名称列表
  ,*/
  String[] getBeanDefinitionNames();
  /**
  ,*返回注册器中已注册的bean数量
  ,*/
  int getBeanDefinitionCount();
  /**
  ,*确定给定的bean名称或者别名是否已在此注册表中使用
  ,*beanName：可以是bean名称或者bean的别名
  ,*/
  boolean isBeanNameInUse(String beanName);
  }
#+end_src
基本上所有的bean工厂都实现了这个接口，让bean工厂拥有bean注册的各种能力。

上面我们用到的AnnotationConfigApplicationContext类也实现了这个接口。

***** BeanNameGenerator接口：bean名称生成器
bean名称生成器，这个接口只有一个方法，用来生成bean的名称
#+begin_src java
  public interface BeanNameGenerator {
      String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry);
  }
#+end_src
spring内置了三个实现

DefaultBeanNameGenerator

默认bean名称生成器，xml中bean未指定名称的时候，默认就会使用这个生成器，默认为：完整的类名#bean编号

AnnotationBeanNameGenerator

注解方式bean名称生成器，比如通过@Component(bean名称)的方式指定bean名称，如果没有通过注解方式指定名称，默认会将完整的类名作为bean名称。

FullyQualifiedAnnotationBeanNameGenerator

将完整的类名作为bean名称

BeanDefinition接口：bean定义信息

用来表示bean定义信息的接口，我们向容器中注册bean之前，会通过xml或者其他方式定义bean的各种配置信息，bean的所有配置信息都会
被转换为一个BeanDefinition对象，然后通过容器中BeanDefinitionRegistry接口中的方法，将BeanDefinition注册到spring容器中，
完成bean的注册操作

这个接口有很多实现类，后面说

**** value为ImportBeanDefinitionRegistrar接口类型
***** 用法
1. 定义ImportBeanDefinitionRegistrar接口实现类，在registerBeanDefinitions方法中使用registry来注册bean
2. 使用@Import来导入步骤1中定义的类
3. 使用步骤2中@Import标注的类作为AnnotationConfigApplicationContext构造参数创建spring容器
4. 使用AnnotationConfigApplicationContext操作bean

Service1.java
#+begin_src java
  public class Service1 {}
#+end_src
Service2.java
#+begin_src java
  public class Service2 {
      private Service1 service1;
      public Service1 getService1() {
          return service1;
      }
      public void setService1(Service1 service1) {
          this.service1 = service1;
      }
      @Override
      public String toString() {
        return "Service2{service1=" + service1 + "}";
      }
  }
#+end_src
来个类实现ImportBeanDefinitionRegistrar接口，然后在里面实现上面两个类的注册，如下：

MyImportBeanDefinitionRegistrar.java
#+begin_src java
  public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
      @Override
      public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
          // 定义一个bean： Service1
          BeanDefinition service1BeanDinition = BeanDefinitionBuilder.genericBeanDefinition(Service1.class).getBeanDefinition();
          // 注册bean
          registry.registerBeanDefinition("service1", service1BeanDinition);
          // 定义一个bean: Service2,通过addPropertyReference注入service1
          BeanDefinition service2BeanDinition = BeanDefinitionBuilder.genericBeanDefinition(Service2.class).addPropertyReference("service1", "service1").getBeanDefinition();
          // 注册bean
          registry.registerBeanDefinition("service2", service2BeanDinition);
      }
  }
#+end_src
注意上面的registerBeanDefinition方法，内部注册了两个bean, Service1和Service2.

上面使用了BeanDefinitionBuilder这个类，这是个BeanDefinition的构造器，内部提供了很多静态方法方便构造BeanDefinition对象。

上面定义的2个bean，和下面xml方式效果一样
#+begin_src xml
  <bean id="service1" class="com.test4.Service1" />
  <bean id="service2" class="com.test4.Service2">
    <property name="service1" ref="service1"/>
  </bean>
#+end_src

**** value为ImportSelector接口类型
***** ImportSelector接口
导入选择器，看一下源码
#+begin_src java
  public interface ImportSelector {
      /**
       ,*返回需要导入的类名的数组，可以是任何普通类，配置类（@Configuration、@Bean、@CompontentScan等标注的类）
       ,*@importingClassMetadata：用来获取被@Import标注的类上面所有的注解信息
       ,*/
      String[] selectImports(AnnotationMetadata importingClassMetadata);
  }
#+end_src
***** 用法（四个步骤）
1. 定义ImportSelector接口实现类，在selectImports返回需要导入的类的名称数组
2. 使用@Import来导入步骤1中定义的类
3. 使用步骤2中@Import标注的类作为AnnotationConfigApplicationContext构造参数创建spring容器
4. 使用AnnotationConfigApplicationContext操作bean
***** 案例
Service1.java
#+begin_src java
  public class Service1 {}
#+end_src
@Configuration标注的配置类：Module1Config
#+begin_src java
  @Configration
  public class Module1Config {
      @Bean
      pubic String name() {
        return "java";
      }
    @Bean
    public String address() {
      return "山东省";
    }
  }
#+end_src
上面定义了两个String类型的bean: name和address

自定义一个ImportSelector，然后返回上面2个类的名称
#+begin_src java
  public class MyImportSelector implements ImportSelector {
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
      return new String[] {
        Service1.class.getName(),
        Module1Config.class.getName()
      }
    }
  }
#+end_src
@Import标注的类，导入MyImportSeletor
#+begin_src java
  @Import({MyImportSelector.class})
  public class MainCofig5{}
#+end_src
测试用例
#+begin_src java
  @Test
  public void test5() {
      //1.通过AnnotationConfigApplicationContext创建spring容器，参数为@Import标注的类
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig5.class);
      //2.输出容器中定义的所有bean信息
      for (String beanName : context.getBeanDefinitionNames()) {
          System.out.println(String.format("%s->%s", beanName,
                                           context.getBean(beanName)));
      }
  }
#+end_src
运行输出
#+begin_src java
  com.javacode2018.lesson001.demo24.test5.Service1-
      >com.javacode2018.lesson001.demo24.test5.Service1@45b4c3a9
      name->java
      address->山东省
#+end_src

**** 牛逼案例
***** 需求
凡是类名中包含service的，调用他们内部任何方法，我们希望调用之后能够输出这些方法的耗时。
***** 实现分析
之前，我们讲过代理，此处我们就可以通过代理来实现，bean实例创建的过程中，我们可以给这些bean生成一个代理，在代理中统计方法的耗时
1. 创建一个代理类，通过代理间接访问需要统计耗时的bean对象
2. 拦截bean的创建，给bean实例生成代理
***** 具体实现
service1.java
#+begin_src java
@Component
  public class Service1 {
      public void m1() {
          System.out.println(this.getClass() + ".m1()");
      }
  }
#+end_src
service2.java
#+begin_src java
  import org.springframework.stereotype.Component;
  @Component
  public class Service2 {
      public void m1() {
          System.out.println(this.getClass() + ".m1()");
      }
  }
#+end_src
创建统计耗时的代理类：使用cglib来实现一个代理类，如下：
#+begin_src java
  import org.springframework.cglib.proxy.Enhancer;
  import org.springframework.cglib.proxy.MethodInterceptor;
  import org.springframework.cglib.proxy.MethodProxy;
  import java.lang.reflect.Method;
  public class CostTimeProxy implements MethodInterceptor {
      //目标对象
      private Object target;
      public CostTimeProxy(Object target) {
          this.target = target;
      }
      @Override
      public Object intercept(Object o, Method method, Object[] objects,
                              MethodProxy methodProxy) throws Throwable {
          long starTime = System.nanoTime();
          //调用被代理对象（即target）的方法，获取结果
          Object result = method.invoke(target, objects); //@1
          long endTime = System.nanoTime();
          System.out.println(method + "，耗时(纳秒)：" + (endTime - starTime));
          return result;
      }
      /**
       ,*创建任意类的代理对象
       ,*
       ,*@param target
       ,*@param <T>
       ,*@return
       ,*/
      public static <T> T createProxy(T target) {
          CostTimeProxy costTimeProxy = new CostTimeProxy(target);
          Enhancer enhancer = new Enhancer();
          enhancer.setCallback(costTimeProxy);
          enhancer.setSuperclass(target.getClass());
          return (T) enhancer.create();
      }
  }
#+end_src
createProxy方法可以用来给某个对象生成代理对象

拦截bean实例的创建，返回代理对象
#+begin_src java
  org.springframework.beans.factory.config.BeanPostProcessor
      public interface BeanPostProcessor {
      /**
       ,*bean初始化之前会调用的方法
       ,*/
      @Nullable
      default Object postProcessBeforeInitialization(Object bean, String beanName)throws BeansException {
          return bean;
      }
      /**
       ,*bean初始化之后会调用的方法
       ,*/
      @Nullable
      default Object postProcessAfterInitialization(Object bean, String beanName)throws BeansException {
          return bean;
      }
  }
#+end_src
这个接口是bean处理器，内部有2个方法，分别在bean初始化前后会进行调用，以后讲声明周期的时候
还会细说的，这里你只需要知道bean初始化之后会调用 postProcessAfterInitialization 方法就
行，这个方法中我们会给bean创建一个代理对象。

创建BeanPostProcessor实现类
#+begin_src java
  import org.springframework.beans.BeansException;
  import org.springframework.beans.factory.config.BeanPostProcessor;
  import org.springframework.lang.Nullable;
  public class MethodCostTimeProxyBeanPostProcessor implements BeanPostProcessor {
      @Nullable
      @Override
      public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
          if (bean.getClass().getName().toLowerCase().contains("service")) {
              return CostTimeProxy.createProxy(bean); //@1
          } else {
              return bean;
          }
      }
  }
#+end_src
@1: 使用上面创建代理类来给当前bean对象创建一个代理

需要将MethodCostTimeProxyBeanPostProcessor注册到容器中才会起作用，下面我们通过@Import结合ImportSelector的方式来导入这个类，将其注册到容器中。

MethodCostTimeImportSelector.java
#+begin_src java
  import com.javacode2018.lesson001.demo23.test4.MethodCostTimeProxyBeanPostProcessor;
  import org.springframework.context.annotation.ImportSelector;
  import org.springframework.core.type.AnnotationMetadata;
  public class MethodCostTimeImportSelector implements ImportSelector {
      @Override
      public String[] selectImports(AnnotationMetadata importingClassMetadata) {
          return new String[]
              {MethodCostTimeProxyBeanPostProcessor.class.getName()};
      }
  }
#+end_src
来一个@Import来导入MethodCostTimeImportSelector

下面我们使用注解的方式，在注解上使用@Import，如下：
#+begin_src java
  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  @Import(MethodCostTimeImportSelector.class)
  public @interface EnableMethodCostTime {
  }
#+end_src

总的配置
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  @ComponentScan
  @EnableMethodCostTime //@1
  public class MainConfig6 {
  }
#+end_src
上面使用了@CompontentScan注解，此时会将Servce1和Service2这两个类注册到容器中。
@1：此处使用了@EnableMethodCostTime注解，而@EnableMethodCostTime注解上使用了
@Import(MethodCostTimeImportSelector.class)，此时MethodCostTimeImportSelector类中
的MethodCostTimeProxyBeanPostProcessor会被注册到容器，会拦截bean的创建，创建耗时代理对象。

运行输出
#+begin_src java
class com.javacode2018.lesson001.demo24.test6.Service1.m1()
public void com.javacode2018.lesson001.demo24.test6.Service1.m1()，耗时(纳秒)：
74200
class com.javacode2018.lesson001.demo24.test6.Service2.m1()
public void com.javacode2018.lesson001.demo24.test6.Service2.m1()，耗时(纳秒)：
33800
#+end_src
太牛逼了，需求实现了。

如果我们不想开启方法耗时统计，只需要将MainConfig6上的@EnableMethodCostTime去掉就可以了，用起来是不是特别爽。

spring中有很多类似的注解，以@EnableXXX开头的注解，基本上都是通过上面这种方式实现的，如：
#+begin_src java
  @EnableAspectJAutoProxy
  @EnableCaching
  @EnableAsync
#+end_src
继续向下看，还有一个更牛逼的接口DeferredImportSelector。

*** DeferredImportSelector接口
spring中的核心功能@EnableAutoConfiguration就是靠着DeferredImportSelector来实现的。

DeferredImportSelector是ImportSelector子接口，既然是ImportSelector子接口，素以也可以通过@Import进行导入，这个接口和ImportSelector不同地方有两点：
1. 延迟导入
2. 指定导入的类的处理顺序
**** 延迟导入
比如@Import的value包含了多个普通类、多个@Configuration标注的配置类、多个ImportSelector接
口的实现类，多个ImportBeanDefinitionRegistrar接口的实现类，还有DeferredImportSelector接口实
现类，此时spring处理这些被导入的类的时候，会将DeferredImportSelector类型的放在最后处理，
会先处理其他被导入的类，其他类会按照value所在的前后顺序进行处理。
那么我们是可以做很多事情的，比如我们可以在DeferredImportSelector导入的类中判断一下容器中是
否已经注册了某个bean，如果没有注册过，那么再来注册。
以后我们会讲到另外一个注解@Conditional，这个注解可以按条件来注册bean，比如可以判断某个
bean不存在的时候才进行注册，某个类存在的时候才进行注册等等各种条件判断，通过@Conditional来
结合DeferredImportSelector可以做很多事情。
***** 案例
来3个配置类，每个配置类中都通过@Bean定义一个String类型的bean,内部输出一句文字。

Configuration1.java
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  public class Configuration1 {
      @Bean
      public String name1() {
          System.out.println("name1");
          return "name1";
      }
  }

#+end_src
Configuration2.java
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  public class Configuration2 {
      @Bean
      public String name2() {
          System.out.println("name2");
          return "name2";
      }
  }
#+end_src
Configuration3.java
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  public class Configuration3 {
      @Bean
      public String name3() {
          System.out.println("name3");
          return "name3";
      }
  }
#+end_src
来一个ImportSelector实现类，导入Configuration1
#+begin_src java
  import org.springframework.context.annotation.ImportSelector;
  import org.springframework.core.type.AnnotationMetadata;
  public class ImportSelector1 implements ImportSelector {
      @Override
      public String[] selectImports(AnnotationMetadata importingClassMetadata) {
          return new String[]{Configuration1.class.getName()};
      }
  }
#+end_src
来一个DeferredImportSelector实现类，导入Cnfiguration2
#+begin_src java
  import org.springframework.context.annotation.DeferredImportSelector;
  import org.springframework.core.type.AnnotationMetadata;
  public class DeferredImportSelector1 implements DeferredImportSelector {
      @Override
      public String[] selectImports(AnnotationMetadata importingClassMetadata) {
          return new String[]{Configuration2.class.getName()};
      }
  }

#+end_src
来一个总的配置类
#+begin_src java
  @Import({DeferredImportSelector1.class,Configuration3.class,ImportSelector1.class,})
  public class MainConfig7 {}
#+end_src
注意上面的@Import中被导入类的顺序：DeferredImportSelector1->Configuration3->ImportSelector1

下面来个测试用例，看一下3个配置文件中@Bean标注的方法被执行的先后顺序。
#+begin_src java
  @Test
  public void test7() {
      //1.通过AnnotationConfigApplicationContext创建spring容器，参数为@Import标注的类
      AnnotationConfigApplicationContext context = new
      AnnotationConfigApplicationContext(MainConfig7.class);
  }
#+end_src
运行输出：
#+begin_src java
  name3
  name1
  name2
#+end_src
输出的结果结合一下@Import中被导入的3个类的顺序，可以看出DeferredImportSelector1是被最后处理的，其他2个是按照value中所在的先后顺序处理的。

指定导入的类的处理顺序
当@Import中有多个DeferredImportSelector接口的实现类时候，可以指定他们的顺序，指定顺序常见的两种方式
****** 实现Ordered接口的方式
#+begin_src java
  org.springframework.core.Ordered
  public interface Ordered {
      int HIGHEST_PRECEDENCE = Integer.MIN_VALUE;
      int LOWEST_PRECEDENCE = Integer.MAX_VALUE;
      int getOrder();
  }
#+end_src
value的值越小，优先级越高
****** 实现Order注解的方式
#+begin_src java
  org.springframework.core.annotation.Order
      @Retention(RetentionPolicy.RUNTIME)
      @Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
      @Documented
      public @interface Order {
          int value() default Ordered.LOWEST_PRECEDENCE;
      }
#+end_src
****** 指定导入类处理顺序案例
来两个配置类，内部都有一个@Bean标注的方法，用来注册一个bean，方法内部输出一段文字

Configuratio1.java
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  public class Configuration1 {
      @Bean
      public String name1() {
          System.out.println("name1");
          return "name1";
      }
  }
#+end_src
Configuraton2.java
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  public class Configuration2 {
      @Bean
      public String name2() {
          System.out.println("name2");
          return "name2";
      }
  }
#+end_src
来2个DeferredImportSelector实现类，分别来导入上面2个配置文件，顺便通过Ordered接口指定一下顺序

DeferredImportSelector1.java
#+begin_src java
  import org.springframework.context.annotation.DeferredImportSelector;
  import org.springframework.core.Ordered;
  import org.springframework.core.type.AnnotationMetadata;
  public class DeferredImportSelector1 implements DeferredImportSelector, Ordered
  {
      @Override
      public String[] selectImports(AnnotationMetadata importingClassMetadata) {
          return new String[]{Configuration1.class.getName()};
      }
      @Override
      public int getOrder() {
          return 2;
      }
  }
#+end_src
DererredImportSelector2.java
#+begin_src java
  import com.javacode2018.lesson001.demo24.test7.Configuration2;
  import org.springframework.context.annotation.DeferredImportSelector;
  import org.springframework.core.Ordered;
  import org.springframework.core.type.AnnotationMetadata;
  public class DeferredImportSelector2 implements DeferredImportSelector, Ordered
  {
      @Override
      public String[] selectImports(AnnotationMetadata importingClassMetadata) {
          return new String[]{Configuration2.class.getName()};
      }
      @Override
      public int getOrder() {
          return 1;
      }
  }
#+end_src
DeferredImportSelector1的order为2，DeferredImportSelector2的order为1，order值越小优先级越高。

来个总的配置类，引入上面两个ImportSelector
MainConfig8.java
#+begin_src java
  import org.springframework.context.annotation.Import;
  @Import({DeferredImportSelector1.class,DeferredImportSelector2.class,})
  public class MainConfig8 {}
#+end_src
测试用例
#+begin_src java
  @Test
  public void test8() {
      //1.通过AnnotationConfigApplicationContext创建spring容器，参数为@Import标注的类
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig8.class);
  }
#+end_src
运行输出顺序为： name2, name1

结果配合order的值，按照order从小到大来处理，可以看出DeferredImportSelector2先被处理的。


** spring源码简介
@Import注解是被下面这个类处理的
#+begin_src java
  org.springframework.context.annotation.ConfigurationClassPostProcessor
#+end_src
前面介绍的@Configuration、@Bean、@CompontentScan、@CompontentScans都是被这个处理的，这个类是高手必经之路，建议花点时间研究研究。

** 总结
1. @Import可以用来批量导入任何普通的组件、配置类，将这些类中定义的所有bean注册到容器中
2. @Import常见的5种用法需要掌握
3. 掌握ImportSelector、ImportBeanDefinitionRegistrar、DeferredImportSelector的用法
4. DeferredImportSelector接口可以实现延迟导入、按序导入的功能
5. spring中很多以@Enable开头的都是使用@Import集合ImportSelector方式实现的
6. BeanDefinitionRegistry接口：bean定义注册器，这个需要掌握常见的方法
* @Conditional通过条件来控制bean的注册
** @Conditional注解
@Conditional注解是从spring4.0才有的，可以用在任何类型或者方法上面，通过@Conditional注解可以配置一些条件判断，当所有条件都满足的时候，被@Conditional标注的目标才会被spring容器处理。

比如可以通过@Conditional来控制bean是否需要注册，控制被@Configuration标注的配置类是需要需要被解析等。

效果就像这段代码，相当于在spring容器解析目标前面加了一个条件判断：
#+begin_src java
  if(@Conditional中配置的多个条件是否都匹配){
      //spring继续处理被@Conditional注解标注的对象
  }
#+end_src
@Conditional源码：
#+begin_src java
  @Target({ElementType.TYPE, ElementType.METHOD})
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  public @interface Conditional {
      Class<? extends Condition>[] value();
  }
#+end_src
这个注解只有一个value参数，Condition类型的数组，Condition是一个接口，表示一个条件判断，内部有个方法返回true或false，
当所有Condition都成立的时候，@Conditional的结果才成立。
** Condition接口
用来表示条件判断的接口，源码如下：
#+begin_src java
  @FunctionalInterface
  public interface Condition {
      /**
       ,*判断条件是否匹配
       ,*context:条件判断上下文
       ,*/
      boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);
  }
#+end_src
是一个函数式接口，内部只有一个matches方法，用来判断条件是否成立的，2个参数：
+ context：条件上下文，ConditionContext接口类型的，可以用来获取容器中的个人信息
+ metadata：用来获取被@Conditional标注的对象上的所有注解信息

@ConditionContext接口
这个接口中提供了一些常用的方法，可以用来获取spring容器中的各种信息，看一下源码：
#+begin_src java
  public interface ConditionContext {
      /**
       ,*返回bean定义注册器，可以通过注册器获取bean定义的各种配置信息
       ,*/
      BeanDefinitionRegistry getRegistry();
      /**
       ,*返回ConfigurableListableBeanFactory类型的bean工厂，相当于一个ioc容器对象
       ,*/
      @Nullable
      ConfigurableListableBeanFactory getBeanFactory();
      /**
       ,*返回当前spring容器的环境配置信息对象
       ,*/
      Environment getEnvironment();
      /**
       ,*返回资源加载器
       ,*/
      ResourceLoader getResourceLoader();
      /**
       ,*返回类加载器
       ,*/
      @Nullable
      ClassLoader getClassLoader();
  }
#+end_src

** 条件判断何时执行
spring对配置类的处理主要分为2个阶段：
*** 配置类解析阶段
会得到一批配置类的信息，和一些需要注册的bean
*** bean注册阶段
将配置类解析阶段得到的配置类和需要注册的bean注册到spring容器中
*** 什么是配置类
1. 类上有@Compontent注解
2. 类上有@Configuration注解
3. 类上有@CompontentScan注解
4. 类上有@Import注解
5. 类上有@ImportResource注解
6. 类中有@Bean标注的方法
判断一个类是不是一个配置类，是否的是下面这个方法，有兴趣的可以看一下：
#+begin_src java
  org.springframework.context.annotation.ConfigurationClassUtils#isConfigurationCandidate
#+end_src
spring中处理这2个过程会循环进行，直到完成所有配置类的解析及所有bean的注册。
*** Spring对配置类处理过程
源码位置：
#+begin_src java
  org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions
#+end_src
整个过程大致的过程如下：
1. 通常我们会通过new AnnotationConfigApplicationContext()传入多个配置类来启动spring容器

2. spring对传入的多个配置类进行解析

3. 配置类解析阶段：这个过程就是处理配置类上面6中注解的过程，此过程中又会发现很多新的配置类，比如@Import导入的一批新的类刚好也符合配置类，而被@CompontentScan扫描到的一些类刚好也是配
置类；此时会对这些新产生的配置类进行同样的过程解析

4. bean注册阶段：配置类解析后，会得到一批配置类和一批需要注册的bean，此时spring容器会将这批配置类作为bean注册到spring容器，同样也会将这批需要注册的bean注册到spring容器

5. 经过上面第3个阶段之后，spring容器中会注册很多新的bean，这些新的bean中可能又有很多新的配置类


从上面过程中可以了解到：

1. 可以在配置类上面加上@Conditional注解，来控制是否需要解析这个配置类，配置类如果不被解析，那么这个配置上面6种注解
的解析都会被跳过

2. 可以在被注册的bean上面加上@Conditional注解，来控制这个bean是否需要注册到spring容器中

3. 如果配置类不会被注册到容器，那么这个配置类解析所产生的所有新的配置类及所产生的所有新的bean都不会被注册到容器
一个配置类被spring处理有2个阶段：配置类解析阶段、bean注册阶段（将配置类作为bean被注册到spring容器)。

如果将Condition接口的实现类作为配置类上@Conditional中，那么这个条件会对两个阶段都有效，此
时通过Condition是无法精细的控制某个阶段的，如果想控制某个阶段，比如可以让他解析，但是不能让
他注册，此时就就需要用到另外一个接口了：ConfigurationCondition

*** ConfigurationCondition接口
接口源码：
#+begin_src java
  public interface ConfigurationCondition extends Condition {
      /**
       ,*条件判断的阶段，是在解析配置类的时候过滤还是在创建bean的时候过滤
       ,*/
      ConfigurationPhase getConfigurationPhase();
      /**
       ,*表示阶段的枚举：2个值
       ,*/
      enum ConfigurationPhase {
          /**
           ,*配置类解析阶段，如果条件为false，配置类将不会被解析
           ,*/
          PARSE_CONFIGURATION,
          /**
           ,*bean注册阶段，如果为false，bean将不会被注册
           ,*/
          REGISTER_BEAN
      }
  }
#+end_src
ConfigurationCondition接口相对于Condition接口多了一个getConfigurationPhase方法，用来指定条
件判断的阶段，是在解析配置类的时候过滤还是在创建bean的时候过滤。

*** @Conditional使用的三个步骤
1. 自定义一个类，实现Condition或ConfigurationCondition接口，实现matches方法
2. 在目标对象上使用@Conditional注解，并指定value的指为自定义的Condition类型
3. 启动spring容器加载资源，此时@Conditional就会起作用了
*** 案例1：阻止配置类的处理
在配置类上面使用@Conditional,这个注解的value指定的Condition当有一个为false的时候，spring就跳过处理这个配置类

自定义一个Condition类
#+begin_src java
  import org.springframework.context.annotation.Condition;
  import org.springframework.context.annotation.ConditionContext;
  import org.springframework.core.type.AnnotatedTypeMetadata;
  public class MyCondition1 implements Condition {
      @Override
      public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
          return false;
      }
  }
#+end_src
matches方法内部我们可以随意发挥，此处为了演示效果就直接返回false。

来个配置类，在配置类上面使用上面这个条件，此时会让配置类失效，如下：
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Conditional;
  import org.springframework.context.annotation.Configuration;
  @Conditional(MyCondition1.class) //@1
  @Configuration
  public class MainConfig3 {
      @Bean
      public String name() { //@1
          return "Java";
      }
  }
#+end_src
@1：使用了自定义的条件类

@2：通过@Bean标注这name这个方法，如果这个配置类成功解析，会将name方法的返回值作为bean注册到spring容器

来个测试类，启动spring容器加载MainConfig3配置类，如下：
#+begin_src java
  import com.javacode2018.lesson001.demo25.test3.MainConfig3;
  import org.junit.Test;
  import org.springframework.context.annotation.AnnotationConfigApplicationContext;
  import java.util.Map;
  public class ConditionTest {
      @Test
      public void test3() {
          AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig3.class);
          Map<String, String> serviceMap = context.getBeansOfType(String.class);
          serviceMap.forEach((beanName, bean) -> {
                  System.out.println(String.format("%s->%s", beanName, bean));
              });
      }
  }
#+end_src
test3中，从容器中获取String类型的bean，运行test3没有任何输出。

我们可以将MainConfig3上面的@Conditional去掉，再次运行输出：name -> Java

*** 案例2：阻止bean的注册
配置类：
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Conditional;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  public class MainConfig4 {
      @Conditional(MyCondition1.class) //@1
      @Bean
      public String name() {
          return "Java";
      }
      @Bean
      public String address() {
          return "山东省济南市";
      }
  }
#+end_src
上面2个方法上面使用了@Bean注解来定义了2个bean，name方法上面使用了@Conditional注解，这
个条件会在name这个bean注册到容器之前会进行判断，当条件为true的时候，name这个bean才会被
注册到容器。

ConditionTest中新增个测试用例来加载上面这个配置类，从容器中获取String类型所有bean输出，代码
如下：
#+begin_src java
  @Test
  public void test4() {
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig4.class);
      Map<String, String> serviceMap = context.getBeansOfType(String.class);
      serviceMap.forEach((beanName, bean) -> {
              System.out.println(String.format("%s->%s", beanName, bean));
          });
  }
#+end_src
运行输出： address->山东省济南市

可以看到容器中只有一个address被注册了，而name这个bean没有被注册。

*** 案例3：bean不存在的时候才注册
**** 需求
IService接口有两个实现类Service1和Service1，这两个类会放在2个配置类中通过@Bean的方式来注册
到容器，此时我们想加个限制，只允许有一个IService类型的bean被注册到容器。

可以在@Bean标注的2个方法上面加上条件限制，当容器中不存在IService类型的bean时，才将这个方
法定义的bean注册到容器，下面来看代码实现。
**** 代码实现
***** 条件判断类： OnMissgBeanCondition
#+begin_src java
  import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
  import org.springframework.context.annotation.Condition;
  import org.springframework.context.annotation.ConditionContext;
  import org.springframework.context.annotation.ConfigurationCondition;
  import org.springframework.core.type.AnnotatedTypeMetadata;
  import java.util.Map;
  public class OnMissingBeanCondition implements Condition {
      @Override
      public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
          //获取bean工厂
          ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
          //从容器中获取IService类型bean
          Map<String, IService> serviceMap = beanFactory.getBeansOfType(IService.class);
          //判断serviceMap是否为空
          return serviceMap.isEmpty();
      }
  }
#+end_src
上面matches方法中会看容器中是否存在IService类型的bean，不存在的时候返回true

IService接口
#+begin_src java
  public interface IService {}
#+end_src
接口有两个实现类

Service1.java
#+begin_src java
  public class Service1 implements IService {}
#+end_src
Service2.java
#+begin_src java
  public class Service2 implements IService {}
#+end_src
来一个配置类负责注册Service到容器
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Conditional;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  public class BeanConfig1 {
      @Conditional(OnMissingBeanCondition.class) //@1
      @Bean
      public IService service1() {
          return new Service1();
      }
  }
#+end_src
@1：方法之前使用了条件判断

再来一个配置类负责注册Service2到容器
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Conditional;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  public class BeanConfig2 {
      @Conditional(OnMissingBeanCondition.class)//@1
      @Bean
      public IService service2() {
          return new Service2();
      }
  }
#+end_src
@1：方法之前使用了条件判断

来一个总的配置类，导入另外两个配置类
#+begin_src java
  import org.springframework.context.annotation.Configuration;
  import org.springframework.context.annotation.Import;
  @Configuration
  @Import({BeanConfig1.class,BeanConfig2.class}) //@1
  public class MainConfig1 {}
#+end_src
@1：通过@Import将其他2个配置类导入

测试用例如下：
#+begin_src java
  @Test
  public void test1() {
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig1.class);
      Map<String, IService> serviceMap = context.getBeansOfType(IService.class);
      serviceMap.forEach((beanName, bean) -> {
              System.out.println(String.format("%s->%s", beanName, bean));
          });
  }
#+end_src
运行输出： service1->com.javacode2018.lesson001.demo25.test1.Service1@2cd76f3

可以看出容器中只有一个IService类型的bean.

可以将@Bean标注的2个方法上面的@Conditional去掉，再运行会输出：
#+begin_src java
  service1->com.javacode2018.lesson001.demo25.test1.Service1@49438269
  service2->com.javacode2018.lesson001.demo25.test1.Service2@ba2f4ec
#+end_src
此时没有条件限制，2个service都会注册到容器。

*** 案例4：根据环境选择配置类
平常我们做项目的时候，有并发和环境，测试环境，线上环境，每个环境中有些信息是不一样的，比如数据库的配置信息，下面
我们来模拟不同环境中使用不同的配置类来注册不同的bean。
**** 自定义个一个条件注解
#+begin_src java
  import org.springframework.context.annotation.Conditional;
  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;
  @Conditional(EnvCondition.class) //@1
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface EnvConditional {
      //环境(测试环境、开发环境、生产环境)
      enum Env { //@2
          TEST, DEV, PROD
      }
      //环境
      Env value() default Env.DEV; //@3
  }

#+end_src
@1：注意这个注解比较特别，这个注解上面使用到了@Conditional注解，这个地方使用到了一个自定义Conditione类：EnvCondition

@2：枚举，表示环境，定义了3个环境

@3：这个参数用指定环境

上面这个注解我们会用在不同的环境的配置类上面
**** 3个配置类
让3个配置类分别再不同环境中生效，会在这些配置类上面使用上面自定义的@EnvConditional注解来做条件限定。

每个配置类中通过@Bean来定义一个名称为name的bean,通过输出这个bean来判断哪个配置类生效了。

测试环境配置类
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  @EnvConditional(EnvConditional.Env.TEST)//@1
  public class TestBeanConfig {
      @Bean
      public String name() {
          return "我是测试环境!";
      }
  }
#+end_src
@1: 指定的测试环境

开发环境配置类
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  @EnvConditional(EnvConditional.Env.DEV) //@1
  public class DevBeanConfig {
      @Bean
      public String name() {
          return "我是开发环境!";
      }
  }
#+end_src
@1: 指定的开发环境

生产环境配置类
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  @EnvConditional(EnvConditional.Env.PROD) //@1
  public class ProdBeanConfig {
      @Bean
      public String name() {
          return "我是生产环境!";
      }
  }
#+end_src
@1: 指定的生产环境

条件类： EnvConditon

条件类会解析配置类上面@EnvConditional注解，得到环境信息。

然后和目前的环境对比，决定返回true还是false,如下：
#+begin_src java
  import org.springframework.context.annotation.Condition;
  import org.springframework.context.annotation.ConditionContext;
  import org.springframework.core.type.AnnotatedTypeMetadata;
  public class EnvCondition implements Condition {
      @Override
      public boolean matches(ConditionContext context, AnnotatedTypeMetadata
                             metadata) {
          //当前需要使用的环境
          EnvConditional.Env curEnv = EnvConditional.Env.DEV; //@1
          //获取使用条件的类上的EnvCondition注解中对应的环境
          EnvConditional.Env env = (EnvConditional.Env)
              metadata.getAllAnnotationAttributes(EnvConditional.class.getName()).get("value").get(0);
          return env.equals(curEnv);
      }
  }
#+end_src
@1：这个用来指定当前使用的环境，此处假定当前使用的是开发环境，这个我们以后可以任意发挥，比如将这些放到配置文件中，此处方便演示效果。

测试用例：
#+begin_src java
  @Test
  public void test2() {
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig2.class);
      System.out.println(context.getBean("name"));
  }
#+end_src
运行输出： 我是开发环境

*** 案例5：Conditon指定优先级
**** 多个Condition按照顺序执行
@Condtional中value指定多个Condtion的时候，默认情况下会按顺序执行，还是通过代码来看一下效果。

下面代码中定义了3个Condition，每个Condition的matches方法中会输出当前类名，然后在配置类上面同时使用这3个Condition：
#+begin_src java
  import org.springframework.context.annotation.Condition;
  import org.springframework.context.annotation.ConditionContext;
  import org.springframework.context.annotation.Conditional;
  import org.springframework.context.annotation.Configuration;
  import org.springframework.core.type.AnnotatedTypeMetadata;
  class Condition1 implements Condition {
      @Override
      public boolean matches(ConditionContext context, AnnotatedTypeMetadata
                             metadata) {
          System.out.println(this.getClass().getName());
          return true;
      }
  }
  class Condition2 implements Condition {
      @Override
      public boolean matches(ConditionContext context, AnnotatedTypeMetadata
                             metadata) {
          System.out.println(this.getClass().getName());
          return true;
      }
  }
  class Condition3 implements Condition {
      @Override
      public boolean matches(ConditionContext context, AnnotatedTypeMetadata
                             metadata) {
          System.out.println(this.getClass().getName());
          return true;
      }
  }
  @Configuration
  @Conditional({Condition1.class, Condition2.class, Condition3.class})
  public class MainConfig5 {
  }
#+end_src
测试用例：
#+begin_src java
  @Test
  public void test5() {
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig5.class);
  }
#+end_src
运行输出：
#+begin_src java
  com.javacode2018.lesson001.demo25.test5.Condition1
  com.javacode2018.lesson001.demo25.test5.Condition2
  com.javacode2018.lesson001.demo25.test5.Condition3
  com.javacode2018.lesson001.demo25.test5.Condition1
  com.javacode2018.lesson001.demo25.test5.Condition2
  com.javacode2018.lesson001.demo25.test5.Condition3
  com.javacode2018.lesson001.demo25.test5.Condition1
  com.javacode2018.lesson001.demo25.test5.Condition2
  com.javacode2018.lesson001.demo25.test5.Condition3
#+end_src
上面有多行输出，是因为spring解析整个配置类的过程中，有好几个地方都会执行条件判断。

咱们只需要关注前3行，可以看出输出的属性和@Conditional中value的值的顺序是一样的。
**** 指定Condition的顺序
自定义的Condition可以实现PriorityOrdered接口或者继承Ordered接口，或者使用@Order注解，通过这些来指定
Condition的优先级。

排序规则： PriorityOrdered asc ------> order  asc

下面这几个都可以指定order的值
+ 接口：org.springframework.core.Ordered，有个getOrder方法用来返回int类型的值
+ 接口：org.springframework.core.PriorityOrdered，继承了Ordered接口，所以也有getOrder方法
+ 注解：org.springframework.core.annotation.Order，有个int类型的value参数指定Order的大小
***** 案例代码
#+begin_src java
  import org.springframework.context.annotation.Condition;
  import org.springframework.context.annotation.ConditionContext;
  import org.springframework.context.annotation.Conditional;
  import org.springframework.context.annotation.Configuration;
  import org.springframework.core.Ordered;
  import org.springframework.core.PriorityOrdered;
  import org.springframework.core.annotation.Order;
  import org.springframework.core.type.AnnotatedTypeMetadata;
  @Order(1) //@1
  class Condition1 implements Condition {
      @Override
      public boolean matches(ConditionContext context, AnnotatedTypeMetadata
                             metadata) {
          System.out.println(this.getClass().getName());
          return true;
      }
  }
  class Condition2 implements Condition, Ordered { //@2
      @Override
      public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
          System.out.println(this.getClass().getName());
          return true;
      }
      @Override
      public int getOrder() { //@3
          return 0;
      }
  }
  class Condition3 implements Condition, PriorityOrdered { //@4
      @Override
      public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
          System.out.println(this.getClass().getName());
          return true;
      }
      @Override
      public int getOrder() {
          return 1000;
      }
  }
  @Configuration
  @Conditional({Condition1.class, Condition2.class, Condition3.class})//@5
  public class MainConfig6 {
  }
#+end_src
@1：Condition1通过@Order指定顺序，值为1

@2：Condition2通过实现了Ordered接口来指定顺序，@3：getOrder方法返回1

@4：Condition3实现了PriorityOrdered接口，实现这个接口需要重写getOrder方法，返回1000

@5：Condtion顺序为1、2、3

根据排序的规则，PriorityOrdered的会排在前面，然后会再按照order升序，最后可以顺序是：Condtion3->Condtion2->Condtion1





*** 案例6：ConfigurationCondition使用
ConfigurationCondition使用的比较少，很多地方对这个基本上也不会去介绍，Condition接口基本上可以满足99%的需求了，
但是springboot中却大量的用到了ConfigurationCondition这个接口。

ConfigurationCondition通过解释比较难以理解，来个案例感受一下：

普通类：Service.java
#+begin_src java
  public class Service{}
#+end_src
来一个配置类，通过配置类注册上面这个Service
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  public class BeanConfig1 {
      @Bean
      public Service service() {
          return new Service();
      }
  }
#+end_src
再来一个配置类，BeanConfig2
#+begin_src java
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  @Configuration
  public class BeanConfig2 {
      @Bean
      public String name() {
          return "Java";
      }
  }
#+end_src
来一个总的配置类
#+begin_src java
  import org.springframework.context.annotation.Configuration;
  import org.springframework.context.annotation.Import;
  @Configuration
  @Import({BeanConfig1.class, BeanConfig2.class})
  public class MainConfig7 {}
#+end_src
上面通过@Import引入了另外两个配置类

测试用例
#+begin_src java
  @Test
  public void test7() {
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig7.class);
      context.getBeansOfType(String.class).forEach((beanName, bean) -> {
              System.out.println(String.format("%s->%s", beanName, bean));
          });
  }
#+end_src
上面从容器中获取String类型的bean，然后输出: name->Java

现在来了一个新需求

当容器中有Service这种类型的bean的时候，BeanConfig2才生效。

很简单那吧，加个Condition就行了，内部判断容器中是否有Service类型的bean,继续

来个自定义的Condition
#+begin_src java
  import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
  import org.springframework.context.annotation.Condition;
  import org.springframework.context.annotation.ConditionContext;
  import org.springframework.core.type.AnnotatedTypeMetadata;
  public class MyCondition1 implements Condition {
      @Override
      public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
          //获取spring容器
          ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
          //判断容器中是否存在Service类型的bean
          boolean existsService = !beanFactory.getBeansOfType(Service.class).isEmpty();
          return existsService;
      }
  }
#+end_src
上面代码很简单，判断容器中是否有IService类型的bean。

BeanConfig2上使用Condition条件判断
#+begin_src java
  @Configuration
  @Conditional(MyCondition1.class)
  public class BeanConfig2 {
      @Bean
      public String name() {
          return "Java";
      }
  }
#+end_src

运行后无任何输出

why?

在文章前面我们说过，配置类的处理会依次经过2个阶段：配置类解析阶段和bean注册阶段，Condition
接口类型的条件会对这两个阶段都有效，解析阶段的时候，容器中是还没有Service这个bean的，配置
类中通过@Bean注解定义的bean在bean注册阶段才会被注册到spring容器，所以BeanConfig2在解析
阶段去容器中是看不到Service这个bean的，所以就被拒绝了。

此时我们需要用到ConfigurationCondition了，让条件判断在bean注册阶段才起效。

自定义一个ConfigurationCondition类
#+begin_src java
  import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
  import org.springframework.context.annotation.ConditionContext;
  import org.springframework.context.annotation.ConfigurationCondition;
  import org.springframework.core.type.AnnotatedTypeMetadata;
  public class MyConfigurationCondition1 implements ConfigurationCondition {
      @Override
      public ConfigurationPhase getConfigurationPhase() {
          return ConfigurationPhase.REGISTER_BEAN; //@1
      }
      @Override
      public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
          //获取spring容器
          ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
          //判断容器中是否存在Service类型的bean
          boolean existsService = !beanFactory.getBeansOfType(Service.class).isEmpty();
          return existsService;
      }
  }
#+end_src
@1：指定条件在bean注册阶段，这个条件才有效

matches方法中的内容直接复制过来，判断规则不变。

修改BeanConfig2的类容

将@Conditional(MyCondition1.class)替换为@Conditional(MyConfigurationCondition1.class)

再次输出： name->Java

此时name这个bean被输出了。

可以再试试将BeanConfig1中service方法上面的@Bean去掉，此时Service就不会被注册到容器，再运
行一下，会发现没有输出了，此时BeanConfig2会失效。

判断bean存不存在的问题，通常会使用ConfigurationCondition这个接口，阶段为：REGISTER_BEAN，这样可以确保条件判断是在bean注册阶段执行的。

对springboot比较熟悉的，它里面有很多@Conditionxxx这样的注解，可以去看一下这些注解，很多都实现了ConfigurationCondition接口。

* 注解实现依赖注入
+ @Autowired
+ @Resource
+ @Primary
+ @Qulifier
** @Autowired:注入依赖对象
*** 作用
实现依赖注入，spring容器会对bean中的所有字段，方法进行遍历，标注有@Autowired注解的，都会进行注入
*** 注解定义
#+begin_src java
  @Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER,
              ElementType.FIELD, ElementType.ANNOTATION_TYPE})
              @Retention(RetentionPolicy.RUNTIME)
              @Documented
              public @interface Autowired {
                  /**
                   ,*Declares whether the annotated dependency is required.
                   ,*<p>Defaults to {@code true}.
                   ,*/
                  boolean required() default true;
              }
#+end_src
可以用在构造器，方法，方法参数，字段，注解上面

参数：required:标注的对象是否必须注入，可能这个对象再容器中不存在，如果为true的时候，找不到匹配
的后选择就会报错，为false的时候，找不到也没关系。
*** Autowire查找候选者的过程
按类型找->通过限定符@Qualifier过滤->@Primary->@Priority->根据名称找（字段名称或者参数名称）

*** 案例1：@Autowired标注在构造器上，通过构造器注入依赖对象
Service1.java
#+begin_src java
  @Component
  public class Service1 {
  }
#+end_src
Service2.java
#+begin_src java
  import org.springframework.stereotype.Component;
  @Component
  public class Service2 {
      private Service1 service1;
      public Service2() { //@1
          System.out.println(this.getClass() + "无参构造器");
      }
      public Service2(Service1 service1) { //@2
          System.out.println(this.getClass() + "有参构造器");
          this.service1 = service1;
      }
      @Override
      public String toString() { //@2
          return "Service2{" + "service1=" + service1 + '}';
      }
  }
#+end_src
Service2中依赖于Service1，有2个构造方法

@1：无参构造器

@2：有参构造器，可以通过这个传入依赖的Service1

@3：重写了toString方法，一会打印测试的时候方便查看

总的配置文件
#+begin_src java
  @ComponentScan // @1
  public class MainConfig0 {}
#+end_src
@1: 会自动扫描当前类所在的包，会将Service1和Service2注册到容器

测试用例
#+begin_src java
  import com.javacode2018.lesson001.demo26.test0.MainConfig0;
  import org.junit.Test;
  import org.springframework.context.annotation.AnnotationConfigApplicationContext;
  public class InjectTest {
      @Test
      public void test0() {
          AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig0.class);
          for (String beanName : context.getBeanDefinitionNames()) {
              System.out.println(String.format("%s->%s", beanName,context.getBean(beanName)));
          }
      }
  }
#+end_src
main方法中启动容器，加载MainConfig0配置类，然后输出容器中所有的bean

运行部分输出
#+begin_src java
  class com.javacode2018.lesson001.demo26.test0.Service2无参构造器
  service1->com.javacode2018.lesson001.demo26.test0.Service1@4a94ee4
  service2->Service2{service1=null}
#+end_src
输出中可以看出调用了Service2的无参构造器，service2中的service1为null

通过@Autowired指定注入的构造器

在Service2有参有参构造器上面加上@Autowired注解，如下：
#+begin_src java
  @Autowired
  public Service2(Service1 service1) {
      System.out.println(this.getClass() + "有参构造器");
      this.service1 = service1;
  }
#+end_src

再次运行test0()
#+begin_src java
class com.javacode2018.lesson001.demo26.test0.Service2有参构造器
service1->com.javacode2018.lesson001.demo26.test0.Service1@4ec4f3a0
service2-
>Service2{service1=com.javacode2018.lesson001.demo26.test0.Service1@4ec4f3a0}
#+end_src
Service2有参构造器被调用了，service2中的service1有值了。


*** 案例2：@Autowired标注在方法上，通过方法注入依赖的对象
Service1.java
#+begin_src java
  @Component
  public class Service1 {}
#+end_src
Service2.java
#+begin_src java
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.stereotype.Component;
  @Component
  public class Service2 {
      private Service1 service1;
      @Autowired
      public void injectService1(Service1 service1) { //@1
          System.out.println(this.getClass().getName() + ".injectService1()");
          this.service1 = service1;
      }
      @Override
      public String toString() {
          return "Service2{" +
              "service1=" + service1 +
              '}';
      }
  }
#+end_src
@1：方法上标注了@Autowired，spring容器会调用这个方法，从容器中查找Service1类型的bean，然后注入。

总的配置文件
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  @ComponentScan
  public class MainConfig1 {}
#+end_src
测试用例
#+begin_src java
  @Test
  public void test1() {
      AnnotationConfigApplicationContext context = new
          AnnotationConfigApplicationContext(MainConfig1.class);
      for (String beanName : context.getBeanDefinitionNames()) {
          System.out.println(String.format("%s->%s", beanName,
                                           context.getBean(beanName)));
      }
  }
#+end_src
运行输出
#+begin_src java
  com.javacode2018.lesson001.demo26.test1.Service2.injectService1()
  service1->com.javacode2018.lesson001.demo26.test1.Service1@9597028
  service2-
  >Service2{service1=com.javacode2018.lesson001.demo26.test1.Service1@9597028}
#+end_src
注入成功
*** 案例3：@Autowired标注在setter方法上，通过setter方法注入
上面2种通过构造器，和通过普通的一个方法注入，不是很常见，可以将@Autowired标注在set方法上
面，来注入指定的对象

Service1.java
#+begin_src java
  import org.springframework.stereotype.Component;
  @Component
  public class Service1 {
  }
#+end_src
Service2.java
#+begin_src java
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.stereotype.Component;
  @Component
  public class Service2 {
      private Service1 service1;
      @Autowired
      public void setService1(Service1 service1) { //@1
          System.out.println(this.getClass().getName() + ".setService1方法");
          this.service1 = service1;
      }
      @Override
      public String toString() {
          return "Service2{" +
              "service1=" + service1 +
              '}';
      }
  }
#+end_src
@1：标准的set方法，方法上使用了 @Autowired，会通过这个方法注入Service1类型的bean对象。

总的配置文件
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  @ComponentScan
  public class MainConfig2 {
  }
#+end_src
测试用例
#+begin_src java
  @Test
  public void test2() {
      AnnotationConfigApplicationContext context = new
          AnnotationConfigApplicationContext(MainConfig2.class);
      for (String beanName : context.getBeanDefinitionNames()) {
          System.out.println(String.format("%s->%s", beanName,
                                           context.getBean(beanName)));
      }
  }
#+end_src
运行输出
#+begin_src java
  com.javacode2018.lesson001.demo26.test2.Service2.setService1方法
  service1->com.javacode2018.lesson001.demo26.test2.Service1@6069db50
  service2-
      >Service2{service1=com.javacode2018.lesson001.demo26.test2.Service1@6069db50}
#+end_src
*** 案例4：@Autowired标注在方法参数上
Service1.java
#+begin_src java
  import org.springframework.stereotype.Component;
  @Component
  public class Service1 {}
#+end_src
Service2.java
#+begin_src java
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.stereotype.Component;
  @Component
  public class Service2 {
      private Service1 service1;
      @Autowired
      public void injectService1(Service1 service1, String name) { //@1
          System.out.println(String.format("%s.injectService1(),{service1=%s,name=%s}", this.getClass().getName(), service1, name));
          this.service1 = service1;
      }
      @Override
      public String toString() {
          return "Service2{" +
              "service1=" + service1 +
              '}';
      }
  }
#+end_src
@1：方法上标注了@Autowired，表示会将这个方法作为注入方法，这个方法有2个参数，spring查找这2个参数对应的bean，然后注入。

第一个参数对应的bean是存在的，第二个是一个String类型的，我们并没有定义String类型bean，一会看看效果

总配置文件
#+begin_src java
  @Test
  public void test3() {
      AnnotationConfigApplicationContext context = new
          AnnotationConfigApplicationContext(MainConfig3.class);
      for (String beanName : context.getBeanDefinitionNames()) {
          System.out.println(String.format("%s->%s", beanName,
                                           context.getBean(beanName)));
      }
  }
#+end_src
运行输出
#+begin_src java
org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating
bean with name 'service2': Unsatisfied dependency expressed through method
'injectService1' parameter 1; nested exception is
org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying
bean of type 'java.lang.String' available: expected at least 1 bean which
qualifies as autowire candidate. Dependency annotations: {}
#+end_src
报错了，从错误信息中可以看出，通过injectService1方法注入的时候，第二个参数为String类型，spring从容器中没有找到String类型的候选bean，所以报错了。

我们可以这么做多个参数的时候，方法上面的@Autowire默认对方法中所有参数起效，如果我们想对某个参数进行特定
的配置，可以在参数上加上@Autowired，这个配置会覆盖方法上面的@Autowired配置。
在第二个参数上面加上@Autowired，设置required为false：表示这个bean不是强制注入的，能找到就
注入，找不到就注入一个null对象，调整一下代码，如下：
#+begin_src java
  @Autowired
  public void injectService1(Service1 service1, @Autowired(required = false) String name) { //@1
      System.out.println(String.format("%s.injectService1(),
                                       {service1=%s,name=%s}", this.getClass().getName(), service1, name));
                                       this.service1 = service1;
                                       }
#+end_src
此时方法的第一个参数被方法上面的@Autowired约束，第二个参数受@Autowired(required = false)约束

再次运行输出
#+begin_src java
com.javacode2018.lesson001.demo26.test3.Service2.injectService1(),
{service1=com.javacode2018.lesson001.demo26.test3.Service1@59309333,name=null}
service1->com.javacode2018.lesson001.demo26.test3.Service1@59309333
service2-
>Service2{service1=com.javacode2018.lesson001.demo26.test3.Service1@59309333}
#+end_src
注入成功了，service1有值，name为null

*** 案例5：@Autowired用在字段上
Service1.java
#+begin_src java
  import org.springframework.stereotype.Component;
  @Component
  public class Service1 {}
#+end_src
Service2.java
#+begin_src java
  import org.springframework.stereotype.Component;
  @Component
  public class Service2 {}
#+end_src
Service3.java
#+begin_src java
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.stereotype.Component;
  @Component
  public class Service3 {
      @Autowired
      private Service1 service1;//@1
      @Autowired
      private Service2 service2;//@2
      @Override
      public String toString() {
          return "Service3{" +
              "service1=" + service1 +
              ", service2=" + service2 +
              '}';
      }
  }
#+end_src
@1和@2：定义了2个字段，上面都标注了@Autowired，spring会去容器中按照类型查找这2种类
型的bean，然后设置给这2个属性。

来个总的配置文件
#+begin_src java
  import org.springframework.context.annotation.ComponentScan;
  @ComponentScan
  public class MainConfig4 {}
#+end_src
测试用例
#+begin_src java
  @Test
  public void test4() {
      AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig4.class);
      for (String beanName : context.getBeanDefinitionNames()) {
          System.out.println(String.format("%s->%s", beanName,
                                           context.getBean(beanName)));
      }
  }
#+end_src
运行输出
#+begin_src java
service1->com.javacode2018.lesson001.demo26.test4.Service1@7e07db1f
service2->com.javacode2018.lesson001.demo26.test4.Service2@1189dd52
service3-
>Service3{service1=com.javacode2018.lesson001.demo26.test4.Service1@7e07db1f,
service2=com.javacode2018.lesson001.demo26.test4.Service2@1189dd52}
#+end_src
service3中标注@Autowired的2个属性都有值了，都被注入成功了。

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src


#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src

#+begin_src java

#+end_src
